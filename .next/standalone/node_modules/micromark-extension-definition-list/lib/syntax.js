import { factorySpace } from 'micromark-factory-space';
import { markdownSpace } from 'micromark-util-character';
import { blankLine } from 'micromark-core-commonmark';
import { tokenTypes } from './types.js';
import { formatEvents, formatEvent, code2Str } from './utils.js';
import { analyzeDefTermFlow, subtokenizeDefTerm } from './defTermFlowToken.js';
import { splice } from 'micromark-util-chunked';
const ignorablePrefixTypes = new Set(["linePrefix", "blockQuotePrefix", "blockQuoteMarker", "blockQuotePrefixWhitespace"]);
const defListConstruct = {
  name: 'defList',
  tokenize: tokenizeDefListStart,
  continuation: {
    tokenize: tokenizeDefListContinuation
  },
  resolveAll: resolveAllDefinitionTerm,
  exit: tokenizeDefListEnd
};
const defListDescriptionPrefixWhitespaceConstruct = {
  tokenize: tokenizeDefListDescriptionPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
export const defList = {
  document: {
    [58]: defListConstruct,
    null: []
  }
};

function resolveAllDefinitionTerm(events, context) {
  /**
   * Resolves all detList events
   *
   * @remarks
   * For each defList events, this does:
   * - create defListTerm event
   * - create defListDescription event
   *
   * And then merge adjacent lists
   *
   */
  let index = 0;

  while (index < events.length) {
    const event = events[index];

    if (event[0] === 'enter' && event[1].type === tokenTypes.defList) {
      // create defListTerms and defListDescriptions inside defList
      index += resolveDefList(index, events, context);
    }

    index++;
  } // merge definition lists


  const dlStack = [];
  index = 0;

  while (index < events.length) {
    const event = events[index];

    if (event[0] === 'enter' && event[1].type === tokenTypes.defList) {
      dlStack.push(event[1]);
    }

    if (event[0] === 'exit' && event[1].type === tokenTypes.defList) {
      let defListFound = false;
      let i = 1;

      while (index + i < events.length) {
        const forwardEvent = events[index + i];

        if (forwardEvent[0] === 'enter' && forwardEvent[1].type === tokenTypes.defList) {
          defListFound = true;
          break;
        } else if (!ignorablePrefixTypes.has(forwardEvent[1].type)) {
          break;
        }

        i++;
      }

      if (defListFound) {
        event[1].end = Object.assign({}, events[index + i][1].end);
        splice(events, index, i + 1, []);
        index -= i;
      } else {
        const token = dlStack.pop();
        event[1] = token;
      }
    }

    index++;
  }

  return events;
}

function resolveDefList(defList_start, events, context) {
  /**
   * Create defListTerms and defListDescriptions
   *
   * @returns Index offset to the end of current defList
   *
   */
  let indexOffset = 0;
  let defListDescriptionToken;
  let expectFirstDescription = true;
  let index = defList_start + 1;
  index += resolveDefinitionTermTo(defList_start, events);

  while (index < events.length) {
    const event = events[index];

    if (event[0] === 'enter' && event[1].type === tokenTypes.defList) {
      index += resolveDefList(index, events, context);
    }

    if (event[0] === 'exit' && event[1].type === tokenTypes.defList) {
      index += addDescriptionExit(index, events);
      defListDescriptionToken = undefined;
      indexOffset = index - defList_start;
      break;
    }

    if (event[0] === 'exit' && event[1].type === tokenTypes.defListDescriptionPrefix) {
      if (!expectFirstDescription) {
        index += addDescriptionExit(index, events);
        defListDescriptionToken = undefined;
      }

      index += addDescriptionEnter(index, events, event[1]._loose);
      expectFirstDescription = false;
    }

    if (event[0] === 'enter' && event[1].type === tokenTypes.defListDescriptionPrefix) {
      // mark loose definition description
      if (events[index - 1][1].type === "lineEndingBlank") {
        event[1]._loose = true;
      } else if (events[index - 1][1].type === "chunkFlow") {
        const flowEvents = events[index - 1][1]._tokenizer.events;

        if (flowEvents[flowEvents.length - 1][1].type === "lineEndingBlank") {
          event[1]._loose = true;
        }
      }
    }

    index++;
  }

  return indexOffset;

  function addDescriptionEnter(index, events, loose) {
    const indexOffset = 1;
    defListDescriptionToken = {
      type: tokenTypes.defListDescription,
      start: Object.assign({}, events[index + 1][1].start),
      end: Object.assign({}, events[index + 1][1].end),
      _loose: loose
    };
    splice(events, index + 1, 0, [['enter', defListDescriptionToken, context]]);
    return indexOffset;
  }

  function addDescriptionExit(index, events) {
    const indexOffset = 1;
    defListDescriptionToken.end = Object.assign({}, events[index - 1][1].end);
    splice(events, index, 0, [['exit', defListDescriptionToken, context]]);
    return indexOffset;
  }
}

function createDefTermEvent(events, chunkFlowIndex, defListStartIndex, flagBlockQuote) {
  /**
   * Insert defListTerm and chunkFlow subtokenized events
   *
   * @returns Index at which defList enter event should be placed
   *
   */
  const context = events[chunkFlowIndex][2];
  const flow = analyzeDefTermFlow(events[chunkFlowIndex][1]);
  const paragraphInfo = flow.paragraph;

  if (paragraphInfo == null) {
    // for some reason there's no paragraph, so create dummy term
    const defListEnterEvent = events[defListStartIndex];
    const termToken = {
      type: tokenTypes.defListTerm,
      start: Object.assign({}, defListEnterEvent[1].start),
      end: Object.assign({}, defListEnterEvent[1].start)
    };
    splice(events, defListStartIndex, 0, [['enter', termToken, context], ['exit', termToken, context]]);
    return defListStartIndex;
  }

  const lazyLines = events[chunkFlowIndex][2].parser.lazy;
  let newDefListStartIndex = 0;
  let flowExitIndex;

  for (let i = chunkFlowIndex; i >= 0; i--) {
    const event = events[i];

    if (event[1].type !== "chunkFlow") {
      newDefListStartIndex = i + 1;
      break;
    }

    if (event[1].start.offset < paragraphInfo.startOffset) {
      newDefListStartIndex = i + 1;
      break;
    }

    if (event[0] === 'exit') {
      if (flagBlockQuote && !lazyLines[event[1].start.line]) {
        newDefListStartIndex = i + 1;
        break;
      }

      flowExitIndex = i;
    } else {
      subtokenizeDefTerm(events, i, flowExitIndex);
      flowExitIndex = undefined;
    }
  }

  return newDefListStartIndex;
}

function resolveDefinitionTermTo(defListStartIndex, events) {
  /**
   * Create defListTerm for current defList
   *
   * @returns Index offset added by new events
   *
   */
  let flowIndex;
  let blockQuoteExit;
  let blockQuoteExitIndex;

  for (let i = defListStartIndex - 1; i >= 0; i--) {
    if (ignorablePrefixTypes.has(events[i][1].type)) continue;

    if (i === defListStartIndex - 1 && events[i][1].type === "blockQuote" && events[i][0] === 'exit') {
      blockQuoteExitIndex = i;
      blockQuoteExit = events[i];
      continue;
    }

    if (events[i][1].type === "chunkFlow") {
      flowIndex = i;
    }

    break;
  }

  // temporarily remove defList enter
  const defListEnterEvent = events[defListStartIndex];
  splice(events, defListStartIndex, 1, []); // temporarily remove blockQuote exit

  if (blockQuoteExitIndex != null) {
    splice(events, blockQuoteExitIndex, 1, []);
  } // create and insert defListTerm events


  let newDefListStartIndex = createDefTermEvent(events, flowIndex, defListStartIndex, blockQuoteExit != null); // put blockQuote exit

  if (blockQuoteExitIndex != null) {
    blockQuoteExit[1].end = Object.assign({}, events[newDefListStartIndex - 1][1].end);
    splice(events, newDefListStartIndex, 0, [blockQuoteExit]);
    newDefListStartIndex += 1;
  } // insert defList enter at right position


  defListEnterEvent[1].start = Object.assign({}, events[newDefListStartIndex][1].start);
  splice(events, newDefListStartIndex, 0, [defListEnterEvent]);
  return newDefListStartIndex - defListStartIndex;
}

function checkPossibleDefTerm(events) {
  var _a;

  if (events.length <= 1) return false;
  const lastEvent = events[events.length - 1];
  const lazyLines = lastEvent[2].parser.lazy;
  let flagBlockQuote = false;
  let termFlowStart;
  let flowEvents;

  for (let i = events.length - 1; i >= 0; i--) {
    const event = events[i];

    if (ignorablePrefixTypes.has(event[1].type)) {
      continue;
    }

    if (i === events.length - 1 && event[1].type === "blockQuote" && event[0] === 'exit') {
      /**
       * something like:
       *
       * ```
       * > blockquote
       * term
       * : description
       * ```
       */
      flagBlockQuote = true;
      continue;
    }

    if (event[1].type === "chunkFlow") {
      if (event[0] === 'enter') {
        flowEvents !== null && flowEvents !== void 0 ? flowEvents : flowEvents = (_a = event[1]._tokenizer) === null || _a === void 0 ? void 0 : _a.events;
        termFlowStart = event;
      }
    } else {
      break;
    }
  }

  if (flowEvents != null && termFlowStart != null) {
    let blanklines = 0;

    for (let i = flowEvents.length - 1; i >= 0; i--) {
      const flowEvent = flowEvents[i];
      const tmpToken = flowEvent[1];
      if (tmpToken.start.offset < termFlowStart[1].start.offset) break;

      if (flowEvent[0] === 'enter' && tmpToken.type === "lineEndingBlank") {
        if (blanklines >= 1) break;
        blanklines++;
      }

      if (tmpToken.type !== "lineEnding" && tmpToken.type !== "linePrefix" && tmpToken.type !== "lineEndingBlank" && tmpToken.type !== "content") {
        if (flagBlockQuote && !lazyLines[tmpToken.end.line]) {
          return false;
        }

        return tmpToken.type === "paragraph" || tmpToken.type === "chunkContent" || tmpToken.type === 'tableHead';
      }
    }
  }

  return false;
}

function tokenizeDefListStart(effects, ok, nok) {
  const self = this; // eslint-disable-line @typescript-eslint/no-this-alias

  if (self.containerState == null) {
    self.containerState = {};
  }

  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;

  if (self.containerState.type == null) {
    // start defList only when definition term found.
    if (checkPossibleDefTerm(self.events)) {
      effects.enter(tokenTypes.defList, {
        _container: true
      });
      self.containerState.type = tokenTypes.defList;
    } else {
      return nok;
    }
  }

  return start;

  function start(code) {
    var _a;

    if (code !== 58) {
      return nok(code);
    }

    effects.enter(tokenTypes.defListDescriptionPrefix, {
      _loose: (_a = self.containerState) === null || _a === void 0 ? void 0 : _a.lastBlankLine
    });
    self.containerState.lastBlankLinke = undefined;
    effects.enter(tokenTypes.defListDescriptionMarker);
    effects.consume(code);
    effects.exit(tokenTypes.defListDescriptionMarker);
    return effects.check(blankLine, onBlank, effects.attempt(defListDescriptionPrefixWhitespaceConstruct, prefixEnd, otherPrefix));
  }

  function onBlank(code) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return prefixEnd(code);
  }

  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter(tokenTypes.defListDescriptionPrefixWhitespace);
      effects.consume(code);
      effects.exit(tokenTypes.defListDescriptionPrefixWhitespace);
      return prefixEnd;
    }

    return nok(code);
  }

  function prefixEnd(code) {
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit(tokenTypes.defListDescriptionPrefix), true).length;
    return ok(code);
  }
}

function tokenizeDefListContinuation(effects, ok, nok) {
  const self = this; // eslint-disable-line @typescript-eslint/no-this-alias

  self.containerState._closeFlow = undefined;
  return effects.check(blankLine, onBlank, notBlank);

  function onBlank(code) {
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    self.containerState.lastBlankLine = true;
    return factorySpace(effects, ok, "linePrefix", self.containerState.size + 1)(code);
  }

  function notBlank(code) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
      self.containerState.furtherBlankLines = undefined;
      self.containerState.initialBlankLine = undefined;
      return notInCurrentItem(code);
    }

    self.containerState.furtherBlankLines = undefined;
    self.containerState.initialBlankLine = undefined;
    self.containerState.lastBlankLine = undefined;
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);
  }

  function notInCurrentItem(code) {
    self.containerState._closeFlow = true;
    self.interrupt = undefined;
    return factorySpace(effects, effects.attempt(defListConstruct, ok, nok), "linePrefix", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);
  }
}

function tokenizeIndent(effects, ok, nok) {
  const self = this; // eslint-disable-line @typescript-eslint/no-this-alias

  return factorySpace(effects, afterPrefix, "linePrefix", self.containerState.size + 1);

  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);
  }
}

function tokenizeDefListDescriptionPrefixWhitespace(effects, ok, nok) {
  const self = this; // eslint-disable-line @typescript-eslint/no-this-alias

  return factorySpace(effects, afterPrefix, tokenTypes.defListDescriptionPrefixWhitespace, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);

  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code) && tail && tail[1].type === tokenTypes.defListDescriptionPrefixWhitespace ? ok(code) : nok(code);
  }
}

function tokenizeDefListEnd(effects) {
  effects.exit(tokenTypes.defList);
}