{"pageProps":{"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    img: \"img\",\n    ol: \"ol\",\n    strong: \"strong\",\n    hr: \"hr\",\n    a: \"a\",\n    h3: \"h3\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {Lede, Examples, Props, DoDont} = _components;\n  if (!DoDont) _missingMdxReference(\"DoDont\", true);\n  if (!Examples) _missingMdxReference(\"Examples\", true);\n  if (!Lede) _missingMdxReference(\"Lede\", true);\n  if (!Props) _missingMdxReference(\"Props\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"frontmattertitle\",\n      children: frontmatter.title\n    }), \"\\n\", _jsx(Lede, {\n      children: _jsx(_components.p, {\n        children: \"Use index filters to allow merchants to filter, search, and sort their index table data and create unique saved views from the results.\"\n      })\n    }), \"\\n\", _jsx(Examples, {}), \"\\n\", _jsx(Props, {\n      componentName: frontmatter.title\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Merchants use filters to:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Create different subsets of list items\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Search list items by typing a query into the text input\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Sort list items by column\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The way that merchants interact with index filters depends on the components that you decide to incorporate. It supports configuration of a search query input, sorting options, and one or more filters that can be made up of different inputs.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Merchants use the tabs in index tables to:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Control which view is visible\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Edit the applied filters and search terms of a view\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Create, rename, duplicate, or delete views\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can create views and control which actions can be performed on a particular view.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"anatomy\",\n      children: \"Anatomy\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/images/components/selection-and-input/index-filters/index-filters-anatomy@2x.png\",\n        alt: \"A diagram of the IndexFilters component showing the components it is composed of.\"\n      }), \"\\nIndex filters are made up of the following:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Tabs\"\n        }), \": A list of saved views. Each tab represents a subset of the list that has been sorted, filtered, and or queried and saved with a unique name. New views can be created directly from the tab list, or by editing the filters, query, or sort selection of an existing view and saving it as new.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Search and filter, and sort buttons\"\n        }), \": The search and filter button allows merchants to toggle the index table from \\\"View\\\" mode to \\\"Filter\\\" mode. When clicked, the button reveals the search field and the filters that allow merchants to edit or create saved views. The sort button activates a popover displaying a list of options merchants can choose from to sort the list items. Merchants can also choose whether the list should be sorted in ascending or descending order.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Filters\"\n        }), \": A set of useful ways to narrow down the list based on the common actions merchants may need to take on the data. The filters should present merchants with form inputs that help them include or exclude list items from the view based on their data.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Action buttons\"\n        }), \": Primary and secondary actions that a merchant can take on the current view. The primary action will always be either \\\"Save\\\" or \\\"Save as\\\" depending on whether the view is mutable, and the secondary action will always be \\\"Cancel\\\".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"accessibility\",\n      children: \"Accessibility\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The filters component relies on the accessibility features of several other components:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/components/overlays/popover\",\n          children: \"Popover\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/components/selection-and-input/choice-list\",\n          children: \"ChoiceList\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/components/overlays/modal\",\n          children: \"Modal\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/components/navigation/tabs\",\n          children: \"Tabs\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/components/overlays/tooltip\",\n          children: \"Tooltip\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"maintain-accessibility-with-custom-features\",\n      children: \"Maintain accessibility with custom features\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since custom HTML can be passed to the component for additional actions, ensure that the filtering system you build is accessible as a whole.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All merchants must be able to:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Identify and understand the labels of all controls\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Be notified of state changes as they use the filter controls\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Complete all actions using a keyboard\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"best-practices\",\n      children: \"Best practices\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Index filters should:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Reduce merchant effort by promoting the filtering categories that are most commonly used\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Include no more than 2 or 3 promoted filters\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Consider small screen sizes when designing the interface for each filter and the total number filters to include\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Use children only for content that’s related or relevant to filtering\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"content-guidelines\",\n      children: \"Content guidelines\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"text-field\",\n      children: \"Text field\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The text field should be clearly labeled so it’s obvious to merchants what they should enter into the field.\"\n    }), \"\\n\", _jsxs(DoDont, {\n      children: [_jsx(_components.h4, {\n        id: \"do\",\n        children: \"Do\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Filter orders\"\n        }), \"\\n\"]\n      }), _jsx(_components.h4, {\n        id: \"dont\",\n        children: \"Don’t\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Enter text here\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"filter-badges\",\n      children: \"Filter badges\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use the name of the filter if the purpose of the name is clear on its own. For example, when you see a filter badge that reads \", _jsx(_components.strong, {\n        children: \"Fulfilled\"\n      }), \", it’s intuitive that it falls under the Fulfillment status category.\"]\n    }), \"\\n\", _jsxs(DoDont, {\n      children: [_jsx(_components.h4, {\n        id: \"do-1\",\n        children: \"Do\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Fulfilled, Unfulfilled\"\n        }), \"\\n\"]\n      }), _jsx(_components.h4, {\n        id: \"dont-1\",\n        children: \"Don’t\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Fulfillment: Fulfilled, Unfulfilled\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If the filter name is ambiguous on its own, add a descriptive word related to the status. For example, \", _jsx(_components.strong, {\n        children: \"Low\"\n      }), \" doesn’t make sense out of context. Add the word “risk” so that merchants know it’s from the Risk category.\"]\n    }), \"\\n\", _jsxs(DoDont, {\n      children: [_jsx(_components.h4, {\n        id: \"do-2\",\n        children: \"Do\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"High risk, Low risk\"\n        }), \"\\n\"]\n      }), _jsx(_components.h4, {\n        id: \"dont-2\",\n        children: \"Don’t\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"High, Low\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Group tags from the same category together.\"\n    }), \"\\n\", _jsxs(DoDont, {\n      children: [_jsx(_components.h4, {\n        id: \"do-3\",\n        children: \"Do\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"(Unfulfilled, Fulfilled)\"\n        }), \"\\n\"]\n      }), _jsx(_components.h4, {\n        id: \"dont-3\",\n        children: \"Don’t\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"(Unfulfilled) (fulfilled)\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If all tag pills selected: truncate in the middle\"\n    }), \"\\n\", _jsxs(DoDont, {\n      children: [_jsx(_components.h4, {\n        id: \"do-4\",\n        children: \"Do\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Paid, par… unpaid\"\n        }), \"\\n\"]\n      }), _jsx(_components.h4, {\n        id: \"dont-4\",\n        children: \"Don’t\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"All payment status filters selected, Paid, unpa…\"\n        }), \"\\n\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Index filters","category":"Selection and input","keywords":["filters","filtering","filter control","tabs","index","list filter","table"],"examples":[{"fileName":"index-filters-default.tsx","title":"Default","description":"An IndexFilters component with view management, search, filtering, and sorting."},{"fileName":"index-filters-with-pinned-filters.tsx","title":"With pinned filters","description":"An IndexFilters component with some of the filters pinned, making them visible by default."},{"fileName":"index-filters-with-filtering-mode.tsx","title":"Filtering mode default","description":"An IndexFilters component with filtering mode enabled by default."},{"fileName":"index-filters-disabled.tsx","title":"Disabled","description":"An IndexFilters component that is disabled."},{"fileName":"index-filters-with-no-filters.tsx","title":"With no filters","description":"An IndexFilters component with only view management, search, and sorting."},{"fileName":"index-filters-with-no-search-or-filters.tsx","title":"With no search or filters","description":"An IndexFilters component with only view management and sorting."}],"previewImg":"/images/components/selection-and-input/index-filters.png"},"scope":{"__remarkNextMdxImporter":{}}},"examples":[{"fileName":"index-filters-default.tsx","title":"Default","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"An IndexFilters component with view management, search, filtering, and sorting.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {\n  TextField,\n  IndexTable,\n  LegacyCard,\n  IndexFilters,\n  useSetIndexFiltersMode,\n  useIndexResourceState,\n  Text,\n  ChoiceList,\n  RangeSlider,\n  Badge,\n} from '@shopify/polaris';\nimport type {IndexFiltersProps, TabProps} from '@shopify/polaris';\nimport {useState, useCallback} from 'react';\n\nfunction IndexFiltersDefaultExample() {\n  const sleep = (ms: number) =>\n    new Promise((resolve) => setTimeout(resolve, ms));\n  const [itemStrings, setItemStrings] = useState([\n    'All',\n    'Unpaid',\n    'Open',\n    'Closed',\n    'Local delivery',\n    'Local pickup',\n  ]);\n  const deleteView = (index: number) => {\n    const newItemStrings = [...itemStrings];\n    newItemStrings.splice(index, 1);\n    setItemStrings(newItemStrings);\n    setSelected(0);\n  };\n\n  const duplicateView = async (name: string) => {\n    setItemStrings([...itemStrings, name]);\n    setSelected(itemStrings.length);\n    await sleep(1);\n    return true;\n  };\n\n  const tabs: TabProps[] = itemStrings.map((item, index) => ({\n    content: item,\n    index,\n    onAction: () => {},\n    id: `${item}-${index}`,\n    isLocked: index === 0,\n    actions:\n      index === 0\n        ? []\n        : [\n            {\n              type: 'rename',\n              onAction: () => {},\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                const newItemsStrings = tabs.map((item, idx) => {\n                  if (idx === index) {\n                    return value;\n                  }\n                  return item.content;\n                });\n                await sleep(1);\n                setItemStrings(newItemsStrings);\n                return true;\n              },\n            },\n            {\n              type: 'duplicate',\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                await sleep(1);\n                duplicateView(value);\n                return true;\n              },\n            },\n            {\n              type: 'edit',\n            },\n            {\n              type: 'delete',\n              onPrimaryAction: async () => {\n                await sleep(1);\n                deleteView(index);\n                return true;\n              },\n            },\n          ],\n  }));\n  const [selected, setSelected] = useState(0);\n  const onCreateNewView = async (value: string) => {\n    await sleep(500);\n    setItemStrings([...itemStrings, value]);\n    setSelected(itemStrings.length);\n    return true;\n  };\n  const sortOptions: IndexFiltersProps['sortOptions'] = [\n    {label: 'Order', value: 'order asc', directionLabel: 'Ascending'},\n    {label: 'Order', value: 'order desc', directionLabel: 'Descending'},\n    {label: 'Customer', value: 'customer asc', directionLabel: 'A-Z'},\n    {label: 'Customer', value: 'customer desc', directionLabel: 'Z-A'},\n    {label: 'Date', value: 'date asc', directionLabel: 'A-Z'},\n    {label: 'Date', value: 'date desc', directionLabel: 'Z-A'},\n    {label: 'Total', value: 'total asc', directionLabel: 'Ascending'},\n    {label: 'Total', value: 'total desc', directionLabel: 'Descending'},\n  ];\n  const [sortSelected, setSortSelected] = useState(['order asc']);\n  const {mode, setMode} = useSetIndexFiltersMode();\n  const onHandleCancel = () => {};\n\n  const onHandleSave = async () => {\n    await sleep(1);\n    return true;\n  };\n\n  const primaryAction: IndexFiltersProps['primaryAction'] =\n    selected === 0\n      ? {\n          type: 'save-as',\n          onAction: onCreateNewView,\n          disabled: false,\n          loading: false,\n        }\n      : {\n          type: 'save',\n          onAction: onHandleSave,\n          disabled: false,\n          loading: false,\n        };\n  const [accountStatus, setAccountStatus] = useState<string[] | undefined>(\n    undefined,\n  );\n  const [moneySpent, setMoneySpent] = useState<[number, number] | undefined>(\n    undefined,\n  );\n  const [taggedWith, setTaggedWith] = useState('');\n  const [queryValue, setQueryValue] = useState('');\n\n  const handleAccountStatusChange = useCallback(\n    (value: string[]) => setAccountStatus(value),\n    [],\n  );\n  const handleMoneySpentChange = useCallback(\n    (value: [number, number]) => setMoneySpent(value),\n    [],\n  );\n  const handleTaggedWithChange = useCallback(\n    (value: string) => setTaggedWith(value),\n    [],\n  );\n  const handleFiltersQueryChange = useCallback(\n    (value: string) => setQueryValue(value),\n    [],\n  );\n  const handleAccountStatusRemove = useCallback(\n    () => setAccountStatus(undefined),\n    [],\n  );\n  const handleMoneySpentRemove = useCallback(\n    () => setMoneySpent(undefined),\n    [],\n  );\n  const handleTaggedWithRemove = useCallback(() => setTaggedWith(''), []);\n  const handleQueryValueRemove = useCallback(() => setQueryValue(''), []);\n  const handleFiltersClearAll = useCallback(() => {\n    handleAccountStatusRemove();\n    handleMoneySpentRemove();\n    handleTaggedWithRemove();\n    handleQueryValueRemove();\n  }, [\n    handleAccountStatusRemove,\n    handleMoneySpentRemove,\n    handleQueryValueRemove,\n    handleTaggedWithRemove,\n  ]);\n\n  const filters = [\n    {\n      key: 'accountStatus',\n      label: 'Account status',\n      filter: (\n        <ChoiceList\n          title=\"Account status\"\n          titleHidden\n          choices={[\n            {label: 'Enabled', value: 'enabled'},\n            {label: 'Not invited', value: 'not invited'},\n            {label: 'Invited', value: 'invited'},\n            {label: 'Declined', value: 'declined'},\n          ]}\n          selected={accountStatus || []}\n          onChange={handleAccountStatusChange}\n          allowMultiple\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'taggedWith',\n      label: 'Tagged with',\n      filter: (\n        <TextField\n          label=\"Tagged with\"\n          value={taggedWith}\n          onChange={handleTaggedWithChange}\n          autoComplete=\"off\"\n          labelHidden\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'moneySpent',\n      label: 'Money spent',\n      filter: (\n        <RangeSlider\n          label=\"Money spent is between\"\n          labelHidden\n          value={moneySpent || [0, 500]}\n          prefix=\"$\"\n          output\n          min={0}\n          max={2000}\n          step={1}\n          onChange={handleMoneySpentChange}\n        />\n      ),\n    },\n  ];\n\n  const appliedFilters: IndexFiltersProps['appliedFilters'] = [];\n  if (accountStatus && !isEmpty(accountStatus)) {\n    const key = 'accountStatus';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, accountStatus),\n      onRemove: handleAccountStatusRemove,\n    });\n  }\n  if (moneySpent) {\n    const key = 'moneySpent';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, moneySpent),\n      onRemove: handleMoneySpentRemove,\n    });\n  }\n  if (!isEmpty(taggedWith)) {\n    const key = 'taggedWith';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, taggedWith),\n      onRemove: handleTaggedWithRemove,\n    });\n  }\n\n  const orders = [\n    {\n      id: '1020',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1020\n        </Text>\n      ),\n      date: 'Jul 20 at 4:34pm',\n      customer: 'Jaydon Stanton',\n      total: '$969.44',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1019',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1019\n        </Text>\n      ),\n      date: 'Jul 20 at 3:46pm',\n      customer: 'Ruben Westerfelt',\n      total: '$701.19',\n      paymentStatus: <Badge progress=\"partiallyComplete\">Partially paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1018',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1018\n        </Text>\n      ),\n      date: 'Jul 20 at 3.44pm',\n      customer: 'Leo Carder',\n      total: '$798.24',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n  ];\n  const resourceName = {\n    singular: 'order',\n    plural: 'orders',\n  };\n\n  const {selectedResources, allResourcesSelected, handleSelectionChange} =\n    useIndexResourceState(orders);\n\n  const rowMarkup = orders.map(\n    (\n      {id, order, date, customer, total, paymentStatus, fulfillmentStatus},\n      index,\n    ) => (\n      <IndexTable.Row\n        id={id}\n        key={id}\n        selected={selectedResources.includes(id)}\n        position={index}\n      >\n        <IndexTable.Cell>\n          <Text variant=\"bodyMd\" fontWeight=\"bold\" as=\"span\">\n            {order}\n          </Text>\n        </IndexTable.Cell>\n        <IndexTable.Cell>{date}</IndexTable.Cell>\n        <IndexTable.Cell>{customer}</IndexTable.Cell>\n        <IndexTable.Cell>{total}</IndexTable.Cell>\n        <IndexTable.Cell>{paymentStatus}</IndexTable.Cell>\n        <IndexTable.Cell>{fulfillmentStatus}</IndexTable.Cell>\n      </IndexTable.Row>\n    ),\n  );\n\n  return (\n    <LegacyCard>\n      <IndexFilters\n        sortOptions={sortOptions}\n        sortSelected={sortSelected}\n        queryValue={queryValue}\n        queryPlaceholder=\"Searching in all\"\n        onQueryChange={handleFiltersQueryChange}\n        onQueryClear={() => setQueryValue('')}\n        onSort={setSortSelected}\n        primaryAction={primaryAction}\n        cancelAction={{\n          onAction: onHandleCancel,\n          disabled: false,\n          loading: false,\n        }}\n        tabs={tabs}\n        selected={selected}\n        onSelect={setSelected}\n        canCreateNewView\n        onCreateNewView={onCreateNewView}\n        filters={filters}\n        appliedFilters={appliedFilters}\n        onClearAll={handleFiltersClearAll}\n        mode={mode}\n        setMode={setMode}\n      />\n      <IndexTable\n        resourceName={resourceName}\n        itemCount={orders.length}\n        selectedItemsCount={\n          allResourcesSelected ? 'All' : selectedResources.length\n        }\n        onSelectionChange={handleSelectionChange}\n        headings={[\n          {title: 'Order'},\n          {title: 'Date'},\n          {title: 'Customer'},\n          {title: 'Total', alignment: 'end'},\n          {title: 'Payment status'},\n          {title: 'Fulfillment status'},\n        ]}\n      >\n        {rowMarkup}\n      </IndexTable>\n    </LegacyCard>\n  );\n\n  function disambiguateLabel(key: string, value: string | any[]): string {\n    switch (key) {\n      case 'moneySpent':\n        return `Money spent is between $${value[0]} and $${value[1]}`;\n      case 'taggedWith':\n        return `Tagged with ${value}`;\n      case 'accountStatus':\n        return (value as string[]).map((val) => `Customer ${val}`).join(', ');\n      default:\n        return value as string;\n    }\n  }\n\n  function isEmpty(value: string | any[]) {\n    if (Array.isArray(value)) {\n      return value.length === 0;\n    } else {\n      return value === '' || value == null;\n    }\n  }\n}\n\n"},{"fileName":"index-filters-with-pinned-filters.tsx","title":"With pinned filters","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"An IndexFilters component with some of the filters pinned, making them visible by default.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {\n  TextField,\n  IndexTable,\n  LegacyCard,\n  IndexFilters,\n  useSetIndexFiltersMode,\n  useIndexResourceState,\n  Text,\n  ChoiceList,\n  RangeSlider,\n  Badge,\n} from '@shopify/polaris';\nimport type {IndexFiltersProps, TabProps} from '@shopify/polaris';\nimport {useState, useCallback} from 'react';\n\nfunction IndexFiltersWithPinnedFiltersExample() {\n  const sleep = (ms: number) =>\n    new Promise((resolve) => setTimeout(resolve, ms));\n  const [itemStrings, setItemStrings] = useState([\n    'All',\n    'Unpaid',\n    'Open',\n    'Closed',\n    'Local delivery',\n    'Local pickup',\n  ]);\n  const deleteView = (index: number) => {\n    const newItemStrings = [...itemStrings];\n    newItemStrings.splice(index, 1);\n    setItemStrings(newItemStrings);\n    setSelected(0);\n  };\n\n  const duplicateView = async (name: string) => {\n    setItemStrings([...itemStrings, name]);\n    setSelected(itemStrings.length);\n    await sleep(1);\n    return true;\n  };\n\n  const tabs: TabProps[] = itemStrings.map((item, index) => ({\n    content: item,\n    index,\n    onAction: () => {},\n    id: `${item}-${index}`,\n    isLocked: index === 0,\n    actions:\n      index === 0\n        ? []\n        : [\n            {\n              type: 'rename',\n              onAction: () => {},\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                const newItemsStrings = tabs.map((item, idx) => {\n                  if (idx === index) {\n                    return value;\n                  }\n                  return item.content;\n                });\n                await sleep(1);\n                setItemStrings(newItemsStrings);\n                return true;\n              },\n            },\n            {\n              type: 'duplicate',\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                await sleep(1);\n                duplicateView(value);\n                return true;\n              },\n            },\n            {\n              type: 'edit',\n            },\n            {\n              type: 'delete',\n              onPrimaryAction: async () => {\n                await sleep(1);\n                deleteView(index);\n                return true;\n              },\n            },\n          ],\n  }));\n  const [selected, setSelected] = useState(0);\n  const onCreateNewView = async (value: string) => {\n    await sleep(500);\n    setItemStrings([...itemStrings, value]);\n    setSelected(itemStrings.length);\n    return true;\n  };\n  const sortOptions: IndexFiltersProps['sortOptions'] = [\n    {label: 'Order', value: 'order asc', directionLabel: 'Ascending'},\n    {label: 'Order', value: 'order desc', directionLabel: 'Descending'},\n    {label: 'Customer', value: 'customer asc', directionLabel: 'A-Z'},\n    {label: 'Customer', value: 'customer desc', directionLabel: 'Z-A'},\n    {label: 'Date', value: 'date asc', directionLabel: 'A-Z'},\n    {label: 'Date', value: 'date desc', directionLabel: 'Z-A'},\n    {label: 'Total', value: 'total asc', directionLabel: 'Ascending'},\n    {label: 'Total', value: 'total desc', directionLabel: 'Descending'},\n  ];\n  const [sortSelected, setSortSelected] = useState(['order asc']);\n  const {mode, setMode} = useSetIndexFiltersMode();\n  const onHandleCancel = () => {};\n\n  const onHandleSave = async () => {\n    await sleep(1);\n    return true;\n  };\n\n  const primaryAction: IndexFiltersProps['primaryAction'] =\n    selected === 0\n      ? {\n          type: 'save-as',\n          onAction: onCreateNewView,\n          disabled: false,\n          loading: false,\n        }\n      : {\n          type: 'save',\n          onAction: onHandleSave,\n          disabled: false,\n          loading: false,\n        };\n  const [accountStatus, setAccountStatus] = useState<string[] | undefined>(\n    undefined,\n  );\n  const [moneySpent, setMoneySpent] = useState<[number, number] | undefined>(\n    undefined,\n  );\n  const [taggedWith, setTaggedWith] = useState('');\n  const [queryValue, setQueryValue] = useState('');\n\n  const handleAccountStatusChange = useCallback(\n    (value: string[]) => setAccountStatus(value),\n    [],\n  );\n  const handleMoneySpentChange = useCallback(\n    (value: [number, number]) => setMoneySpent(value),\n    [],\n  );\n  const handleTaggedWithChange = useCallback(\n    (value: string) => setTaggedWith(value),\n    [],\n  );\n  const handleFiltersQueryChange = useCallback(\n    (value: string) => setQueryValue(value),\n    [],\n  );\n  const handleAccountStatusRemove = useCallback(\n    () => setAccountStatus(undefined),\n    [],\n  );\n  const handleMoneySpentRemove = useCallback(\n    () => setMoneySpent(undefined),\n    [],\n  );\n  const handleTaggedWithRemove = useCallback(() => setTaggedWith(''), []);\n  const handleQueryValueRemove = useCallback(() => setQueryValue(''), []);\n  const handleFiltersClearAll = useCallback(() => {\n    handleAccountStatusRemove();\n    handleMoneySpentRemove();\n    handleTaggedWithRemove();\n    handleQueryValueRemove();\n  }, [\n    handleAccountStatusRemove,\n    handleMoneySpentRemove,\n    handleQueryValueRemove,\n    handleTaggedWithRemove,\n  ]);\n\n  const filters = [\n    {\n      key: 'accountStatus',\n      label: 'Account status',\n      filter: (\n        <ChoiceList\n          title=\"Account status\"\n          titleHidden\n          choices={[\n            {label: 'Enabled', value: 'enabled'},\n            {label: 'Not invited', value: 'not invited'},\n            {label: 'Invited', value: 'invited'},\n            {label: 'Declined', value: 'declined'},\n          ]}\n          selected={accountStatus || []}\n          onChange={handleAccountStatusChange}\n          allowMultiple\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'taggedWith',\n      label: 'Tagged with',\n      filter: (\n        <TextField\n          label=\"Tagged with\"\n          value={taggedWith}\n          onChange={handleTaggedWithChange}\n          autoComplete=\"off\"\n          labelHidden\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'moneySpent',\n      label: 'Money spent',\n      filter: (\n        <RangeSlider\n          label=\"Money spent is between\"\n          labelHidden\n          value={moneySpent || [0, 500]}\n          prefix=\"$\"\n          output\n          min={0}\n          max={2000}\n          step={1}\n          onChange={handleMoneySpentChange}\n        />\n      ),\n    },\n  ];\n\n  const appliedFilters: IndexFiltersProps['appliedFilters'] = [];\n  if (accountStatus && !isEmpty(accountStatus)) {\n    const key = 'accountStatus';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, accountStatus),\n      onRemove: handleAccountStatusRemove,\n    });\n  }\n  if (moneySpent) {\n    const key = 'moneySpent';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, moneySpent),\n      onRemove: handleMoneySpentRemove,\n    });\n  }\n  if (!isEmpty(taggedWith)) {\n    const key = 'taggedWith';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, taggedWith),\n      onRemove: handleTaggedWithRemove,\n    });\n  }\n\n  const orders = [\n    {\n      id: '1020',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1020\n        </Text>\n      ),\n      date: 'Jul 20 at 4:34pm',\n      customer: 'Jaydon Stanton',\n      total: '$969.44',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1019',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1019\n        </Text>\n      ),\n      date: 'Jul 20 at 3:46pm',\n      customer: 'Ruben Westerfelt',\n      total: '$701.19',\n      paymentStatus: <Badge progress=\"partiallyComplete\">Partially paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1018',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1018\n        </Text>\n      ),\n      date: 'Jul 20 at 3.44pm',\n      customer: 'Leo Carder',\n      total: '$798.24',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n  ];\n  const resourceName = {\n    singular: 'order',\n    plural: 'orders',\n  };\n\n  const {selectedResources, allResourcesSelected, handleSelectionChange} =\n    useIndexResourceState(orders);\n\n  const rowMarkup = orders.map(\n    (\n      {id, order, date, customer, total, paymentStatus, fulfillmentStatus},\n      index,\n    ) => (\n      <IndexTable.Row\n        id={id}\n        key={id}\n        selected={selectedResources.includes(id)}\n        position={index}\n      >\n        <IndexTable.Cell>\n          <Text variant=\"bodyMd\" fontWeight=\"bold\" as=\"span\">\n            {order}\n          </Text>\n        </IndexTable.Cell>\n        <IndexTable.Cell>{date}</IndexTable.Cell>\n        <IndexTable.Cell>{customer}</IndexTable.Cell>\n        <IndexTable.Cell>{total}</IndexTable.Cell>\n        <IndexTable.Cell>{paymentStatus}</IndexTable.Cell>\n        <IndexTable.Cell>{fulfillmentStatus}</IndexTable.Cell>\n      </IndexTable.Row>\n    ),\n  );\n\n  return (\n    <LegacyCard>\n      <IndexFilters\n        sortOptions={sortOptions}\n        sortSelected={sortSelected}\n        queryValue={queryValue}\n        queryPlaceholder=\"Searching in all\"\n        onQueryChange={handleFiltersQueryChange}\n        onQueryClear={() => setQueryValue('')}\n        onSort={setSortSelected}\n        primaryAction={primaryAction}\n        cancelAction={{\n          onAction: onHandleCancel,\n          disabled: false,\n          loading: false,\n        }}\n        tabs={tabs}\n        selected={selected}\n        onSelect={setSelected}\n        canCreateNewView\n        onCreateNewView={onCreateNewView}\n        filters={filters}\n        appliedFilters={appliedFilters}\n        onClearAll={handleFiltersClearAll}\n        mode={mode}\n        setMode={setMode}\n      />\n      <IndexTable\n        resourceName={resourceName}\n        itemCount={orders.length}\n        selectedItemsCount={\n          allResourcesSelected ? 'All' : selectedResources.length\n        }\n        onSelectionChange={handleSelectionChange}\n        headings={[\n          {title: 'Order'},\n          {title: 'Date'},\n          {title: 'Customer'},\n          {title: 'Total', alignment: 'end'},\n          {title: 'Payment status'},\n          {title: 'Fulfillment status'},\n        ]}\n      >\n        {rowMarkup}\n      </IndexTable>\n    </LegacyCard>\n  );\n\n  function disambiguateLabel(key: string, value: string | any[]): string {\n    switch (key) {\n      case 'moneySpent':\n        return `Money spent is between $${value[0]} and $${value[1]}`;\n      case 'taggedWith':\n        return `Tagged with ${value}`;\n      case 'accountStatus':\n        return (value as string[]).map((val) => `Customer ${val}`).join(', ');\n      default:\n        return value as string;\n    }\n  }\n\n  function isEmpty(value: string | any[]) {\n    if (Array.isArray(value)) {\n      return value.length === 0;\n    } else {\n      return value === '' || value == null;\n    }\n  }\n}\n\n"},{"fileName":"index-filters-with-filtering-mode.tsx","title":"Filtering mode default","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"An IndexFilters component with filtering mode enabled by default.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {\n  TextField,\n  IndexTable,\n  LegacyCard,\n  IndexFilters,\n  useSetIndexFiltersMode,\n  IndexFiltersMode,\n  useIndexResourceState,\n  Text,\n  ChoiceList,\n  RangeSlider,\n  Badge,\n} from '@shopify/polaris';\nimport type {IndexFiltersProps, TabProps} from '@shopify/polaris';\nimport {useState, useCallback} from 'react';\n\nfunction IndexFiltersWithFilteringModeExample() {\n  const sleep = (ms: number) =>\n    new Promise((resolve) => setTimeout(resolve, ms));\n  const [itemStrings, setItemStrings] = useState([\n    'All',\n    'Unpaid',\n    'Open',\n    'Closed',\n    'Local delivery',\n    'Local pickup',\n  ]);\n  const deleteView = (index: number) => {\n    const newItemStrings = [...itemStrings];\n    newItemStrings.splice(index, 1);\n    setItemStrings(newItemStrings);\n    setSelected(0);\n  };\n\n  const duplicateView = async (name: string) => {\n    setItemStrings([...itemStrings, name]);\n    setSelected(itemStrings.length);\n    await sleep(1);\n    return true;\n  };\n\n  const tabs: TabProps[] = itemStrings.map((item, index) => ({\n    content: item,\n    index,\n    onAction: () => {},\n    id: `${item}-${index}`,\n    isLocked: index === 0,\n    actions:\n      index === 0\n        ? []\n        : [\n            {\n              type: 'rename',\n              onAction: () => {},\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                const newItemsStrings = tabs.map((item, idx) => {\n                  if (idx === index) {\n                    return value;\n                  }\n                  return item.content;\n                });\n                await sleep(1);\n                setItemStrings(newItemsStrings);\n                return true;\n              },\n            },\n            {\n              type: 'duplicate',\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                await sleep(1);\n                duplicateView(value);\n                return true;\n              },\n            },\n            {\n              type: 'edit',\n            },\n            {\n              type: 'delete',\n              onPrimaryAction: async () => {\n                await sleep(1);\n                deleteView(index);\n                return true;\n              },\n            },\n          ],\n  }));\n  const [selected, setSelected] = useState(0);\n  const onCreateNewView = async (value: string) => {\n    await sleep(500);\n    setItemStrings([...itemStrings, value]);\n    setSelected(itemStrings.length);\n    return true;\n  };\n  const sortOptions: IndexFiltersProps['sortOptions'] = [\n    {label: 'Order', value: 'order asc', directionLabel: 'Ascending'},\n    {label: 'Order', value: 'order desc', directionLabel: 'Descending'},\n    {label: 'Customer', value: 'customer asc', directionLabel: 'A-Z'},\n    {label: 'Customer', value: 'customer desc', directionLabel: 'Z-A'},\n    {label: 'Date', value: 'date asc', directionLabel: 'A-Z'},\n    {label: 'Date', value: 'date desc', directionLabel: 'Z-A'},\n    {label: 'Total', value: 'total asc', directionLabel: 'Ascending'},\n    {label: 'Total', value: 'total desc', directionLabel: 'Descending'},\n  ];\n  const [sortSelected, setSortSelected] = useState(['order asc']);\n  const {mode, setMode} = useSetIndexFiltersMode(IndexFiltersMode.Filtering);\n  const onHandleCancel = () => {};\n\n  const onHandleSave = async () => {\n    await sleep(1);\n    return true;\n  };\n\n  const primaryAction: IndexFiltersProps['primaryAction'] =\n    selected === 0\n      ? {\n          type: 'save-as',\n          onAction: onCreateNewView,\n          disabled: false,\n          loading: false,\n        }\n      : {\n          type: 'save',\n          onAction: onHandleSave,\n          disabled: false,\n          loading: false,\n        };\n  const [accountStatus, setAccountStatus] = useState<string[] | undefined>(\n    undefined,\n  );\n  const [moneySpent, setMoneySpent] = useState<[number, number] | undefined>(\n    undefined,\n  );\n  const [taggedWith, setTaggedWith] = useState('');\n  const [queryValue, setQueryValue] = useState('');\n\n  const handleAccountStatusChange = useCallback(\n    (value: string[]) => setAccountStatus(value),\n    [],\n  );\n  const handleMoneySpentChange = useCallback(\n    (value: [number, number]) => setMoneySpent(value),\n    [],\n  );\n  const handleTaggedWithChange = useCallback(\n    (value: string) => setTaggedWith(value),\n    [],\n  );\n  const handleFiltersQueryChange = useCallback(\n    (value: string) => setQueryValue(value),\n    [],\n  );\n  const handleAccountStatusRemove = useCallback(\n    () => setAccountStatus(undefined),\n    [],\n  );\n  const handleMoneySpentRemove = useCallback(\n    () => setMoneySpent(undefined),\n    [],\n  );\n  const handleTaggedWithRemove = useCallback(() => setTaggedWith(''), []);\n  const handleQueryValueRemove = useCallback(() => setQueryValue(''), []);\n  const handleFiltersClearAll = useCallback(() => {\n    handleAccountStatusRemove();\n    handleMoneySpentRemove();\n    handleTaggedWithRemove();\n    handleQueryValueRemove();\n  }, [\n    handleAccountStatusRemove,\n    handleMoneySpentRemove,\n    handleQueryValueRemove,\n    handleTaggedWithRemove,\n  ]);\n\n  const filters = [\n    {\n      key: 'accountStatus',\n      label: 'Account status',\n      filter: (\n        <ChoiceList\n          title=\"Account status\"\n          titleHidden\n          choices={[\n            {label: 'Enabled', value: 'enabled'},\n            {label: 'Not invited', value: 'not invited'},\n            {label: 'Invited', value: 'invited'},\n            {label: 'Declined', value: 'declined'},\n          ]}\n          selected={accountStatus || []}\n          onChange={handleAccountStatusChange}\n          allowMultiple\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'taggedWith',\n      label: 'Tagged with',\n      filter: (\n        <TextField\n          label=\"Tagged with\"\n          value={taggedWith}\n          onChange={handleTaggedWithChange}\n          autoComplete=\"off\"\n          labelHidden\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'moneySpent',\n      label: 'Money spent',\n      filter: (\n        <RangeSlider\n          label=\"Money spent is between\"\n          labelHidden\n          value={moneySpent || [0, 500]}\n          prefix=\"$\"\n          output\n          min={0}\n          max={2000}\n          step={1}\n          onChange={handleMoneySpentChange}\n        />\n      ),\n    },\n  ];\n\n  const appliedFilters: IndexFiltersProps['appliedFilters'] = [];\n  if (accountStatus && !isEmpty(accountStatus)) {\n    const key = 'accountStatus';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, accountStatus),\n      onRemove: handleAccountStatusRemove,\n    });\n  }\n  if (moneySpent) {\n    const key = 'moneySpent';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, moneySpent),\n      onRemove: handleMoneySpentRemove,\n    });\n  }\n  if (!isEmpty(taggedWith)) {\n    const key = 'taggedWith';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, taggedWith),\n      onRemove: handleTaggedWithRemove,\n    });\n  }\n\n  const orders = [\n    {\n      id: '1020',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1020\n        </Text>\n      ),\n      date: 'Jul 20 at 4:34pm',\n      customer: 'Jaydon Stanton',\n      total: '$969.44',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1019',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1019\n        </Text>\n      ),\n      date: 'Jul 20 at 3:46pm',\n      customer: 'Ruben Westerfelt',\n      total: '$701.19',\n      paymentStatus: <Badge progress=\"partiallyComplete\">Partially paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1018',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1018\n        </Text>\n      ),\n      date: 'Jul 20 at 3.44pm',\n      customer: 'Leo Carder',\n      total: '$798.24',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n  ];\n  const resourceName = {\n    singular: 'order',\n    plural: 'orders',\n  };\n\n  const {selectedResources, allResourcesSelected, handleSelectionChange} =\n    useIndexResourceState(orders);\n\n  const rowMarkup = orders.map(\n    (\n      {id, order, date, customer, total, paymentStatus, fulfillmentStatus},\n      index,\n    ) => (\n      <IndexTable.Row\n        id={id}\n        key={id}\n        selected={selectedResources.includes(id)}\n        position={index}\n      >\n        <IndexTable.Cell>\n          <Text variant=\"bodyMd\" fontWeight=\"bold\" as=\"span\">\n            {order}\n          </Text>\n        </IndexTable.Cell>\n        <IndexTable.Cell>{date}</IndexTable.Cell>\n        <IndexTable.Cell>{customer}</IndexTable.Cell>\n        <IndexTable.Cell>{total}</IndexTable.Cell>\n        <IndexTable.Cell>{paymentStatus}</IndexTable.Cell>\n        <IndexTable.Cell>{fulfillmentStatus}</IndexTable.Cell>\n      </IndexTable.Row>\n    ),\n  );\n\n  return (\n    <LegacyCard>\n      <IndexFilters\n        sortOptions={sortOptions}\n        sortSelected={sortSelected}\n        queryValue={queryValue}\n        queryPlaceholder=\"Searching in all\"\n        onQueryChange={handleFiltersQueryChange}\n        onQueryClear={() => setQueryValue('')}\n        onSort={setSortSelected}\n        primaryAction={primaryAction}\n        cancelAction={{\n          onAction: onHandleCancel,\n          disabled: false,\n          loading: false,\n        }}\n        tabs={tabs}\n        selected={selected}\n        onSelect={setSelected}\n        canCreateNewView\n        onCreateNewView={onCreateNewView}\n        filters={filters}\n        appliedFilters={appliedFilters}\n        onClearAll={handleFiltersClearAll}\n        mode={mode}\n        setMode={setMode}\n      />\n      <IndexTable\n        resourceName={resourceName}\n        itemCount={orders.length}\n        selectedItemsCount={\n          allResourcesSelected ? 'All' : selectedResources.length\n        }\n        onSelectionChange={handleSelectionChange}\n        headings={[\n          {title: 'Order'},\n          {title: 'Date'},\n          {title: 'Customer'},\n          {title: 'Total', alignment: 'end'},\n          {title: 'Payment status'},\n          {title: 'Fulfillment status'},\n        ]}\n      >\n        {rowMarkup}\n      </IndexTable>\n    </LegacyCard>\n  );\n\n  function disambiguateLabel(key: string, value: string | any[]): string {\n    switch (key) {\n      case 'moneySpent':\n        return `Money spent is between $${value[0]} and $${value[1]}`;\n      case 'taggedWith':\n        return `Tagged with ${value}`;\n      case 'accountStatus':\n        return (value as string[]).map((val) => `Customer ${val}`).join(', ');\n      default:\n        return value as string;\n    }\n  }\n\n  function isEmpty(value: string | any[]) {\n    if (Array.isArray(value)) {\n      return value.length === 0;\n    } else {\n      return value === '' || value == null;\n    }\n  }\n}\n\n"},{"fileName":"index-filters-disabled.tsx","title":"Disabled","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"An IndexFilters component that is disabled.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {\n  TextField,\n  IndexTable,\n  LegacyCard,\n  IndexFilters,\n  useSetIndexFiltersMode,\n  useIndexResourceState,\n  Text,\n  ChoiceList,\n  RangeSlider,\n  Badge,\n} from '@shopify/polaris';\nimport type {IndexFiltersProps, TabProps} from '@shopify/polaris';\nimport {useState, useCallback} from 'react';\n\nfunction IndexFiltersDisabledExample() {\n  const sleep = (ms: number) =>\n    new Promise((resolve) => setTimeout(resolve, ms));\n  const [itemStrings, setItemStrings] = useState([\n    'All',\n    'Unpaid',\n    'Open',\n    'Closed',\n    'Local delivery',\n    'Local pickup',\n  ]);\n  const deleteView = (index: number) => {\n    const newItemStrings = [...itemStrings];\n    newItemStrings.splice(index, 1);\n    setItemStrings(newItemStrings);\n    setSelected(0);\n  };\n\n  const duplicateView = async (name: string) => {\n    setItemStrings([...itemStrings, name]);\n    setSelected(itemStrings.length);\n    await sleep(1);\n    return true;\n  };\n\n  const tabs: TabProps[] = itemStrings.map((item, index) => ({\n    content: item,\n    index,\n    onAction: () => {},\n    id: `${item}-${index}`,\n    isLocked: index === 0,\n    actions:\n      index === 0\n        ? []\n        : [\n            {\n              type: 'rename',\n              onAction: () => {},\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                const newItemsStrings = tabs.map((item, idx) => {\n                  if (idx === index) {\n                    return value;\n                  }\n                  return item.content;\n                });\n                await sleep(1);\n                setItemStrings(newItemsStrings);\n                return true;\n              },\n            },\n            {\n              type: 'duplicate',\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                await sleep(1);\n                duplicateView(value);\n                return true;\n              },\n            },\n            {\n              type: 'edit',\n            },\n            {\n              type: 'delete',\n              onPrimaryAction: async () => {\n                await sleep(1);\n                deleteView(index);\n                return true;\n              },\n            },\n          ],\n  }));\n  const [selected, setSelected] = useState(0);\n  const onCreateNewView = async (value: string) => {\n    await sleep(500);\n    setItemStrings([...itemStrings, value]);\n    setSelected(itemStrings.length);\n    return true;\n  };\n  const sortOptions: IndexFiltersProps['sortOptions'] = [\n    {label: 'Order', value: 'order asc', directionLabel: 'Ascending'},\n    {label: 'Order', value: 'order desc', directionLabel: 'Descending'},\n    {label: 'Customer', value: 'customer asc', directionLabel: 'A-Z'},\n    {label: 'Customer', value: 'customer desc', directionLabel: 'Z-A'},\n    {label: 'Date', value: 'date asc', directionLabel: 'A-Z'},\n    {label: 'Date', value: 'date desc', directionLabel: 'Z-A'},\n    {label: 'Total', value: 'total asc', directionLabel: 'Ascending'},\n    {label: 'Total', value: 'total desc', directionLabel: 'Descending'},\n  ];\n  const [sortSelected, setSortSelected] = useState(['order asc']);\n  const {mode, setMode} = useSetIndexFiltersMode();\n  const onHandleCancel = () => {};\n\n  const onHandleSave = async () => {\n    await sleep(1);\n    return true;\n  };\n\n  const primaryAction: IndexFiltersProps['primaryAction'] =\n    selected === 0\n      ? {\n          type: 'save-as',\n          onAction: onCreateNewView,\n          disabled: false,\n          loading: false,\n        }\n      : {\n          type: 'save',\n          onAction: onHandleSave,\n          disabled: false,\n          loading: false,\n        };\n  const [accountStatus, setAccountStatus] = useState<string[] | undefined>(\n    undefined,\n  );\n  const [moneySpent, setMoneySpent] = useState<[number, number] | undefined>(\n    undefined,\n  );\n  const [taggedWith, setTaggedWith] = useState('');\n  const [queryValue, setQueryValue] = useState('');\n\n  const handleAccountStatusChange = useCallback(\n    (value: string[]) => setAccountStatus(value),\n    [],\n  );\n  const handleMoneySpentChange = useCallback(\n    (value: [number, number]) => setMoneySpent(value),\n    [],\n  );\n  const handleTaggedWithChange = useCallback(\n    (value: string) => setTaggedWith(value),\n    [],\n  );\n  const handleFiltersQueryChange = useCallback(\n    (value: string) => setQueryValue(value),\n    [],\n  );\n  const handleAccountStatusRemove = useCallback(\n    () => setAccountStatus(undefined),\n    [],\n  );\n  const handleMoneySpentRemove = useCallback(\n    () => setMoneySpent(undefined),\n    [],\n  );\n  const handleTaggedWithRemove = useCallback(() => setTaggedWith(''), []);\n  const handleQueryValueRemove = useCallback(() => setQueryValue(''), []);\n  const handleFiltersClearAll = useCallback(() => {\n    handleAccountStatusRemove();\n    handleMoneySpentRemove();\n    handleTaggedWithRemove();\n    handleQueryValueRemove();\n  }, [\n    handleAccountStatusRemove,\n    handleMoneySpentRemove,\n    handleQueryValueRemove,\n    handleTaggedWithRemove,\n  ]);\n\n  const filters = [\n    {\n      key: 'accountStatus',\n      label: 'Account status',\n      filter: (\n        <ChoiceList\n          title=\"Account status\"\n          titleHidden\n          choices={[\n            {label: 'Enabled', value: 'enabled'},\n            {label: 'Not invited', value: 'not invited'},\n            {label: 'Invited', value: 'invited'},\n            {label: 'Declined', value: 'declined'},\n          ]}\n          selected={accountStatus || []}\n          onChange={handleAccountStatusChange}\n          allowMultiple\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'taggedWith',\n      label: 'Tagged with',\n      filter: (\n        <TextField\n          label=\"Tagged with\"\n          value={taggedWith}\n          onChange={handleTaggedWithChange}\n          autoComplete=\"off\"\n          labelHidden\n        />\n      ),\n      shortcut: true,\n    },\n    {\n      key: 'moneySpent',\n      label: 'Money spent',\n      filter: (\n        <RangeSlider\n          label=\"Money spent is between\"\n          labelHidden\n          value={moneySpent || [0, 500]}\n          prefix=\"$\"\n          output\n          min={0}\n          max={2000}\n          step={1}\n          onChange={handleMoneySpentChange}\n        />\n      ),\n    },\n  ];\n\n  const appliedFilters: IndexFiltersProps['appliedFilters'] = [];\n  if (accountStatus && !isEmpty(accountStatus)) {\n    const key = 'accountStatus';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, accountStatus),\n      onRemove: handleAccountStatusRemove,\n    });\n  }\n  if (moneySpent) {\n    const key = 'moneySpent';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, moneySpent),\n      onRemove: handleMoneySpentRemove,\n    });\n  }\n  if (!isEmpty(taggedWith)) {\n    const key = 'taggedWith';\n    appliedFilters.push({\n      key,\n      label: disambiguateLabel(key, taggedWith),\n      onRemove: handleTaggedWithRemove,\n    });\n  }\n\n  const orders = [\n    {\n      id: '1020',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1020\n        </Text>\n      ),\n      date: 'Jul 20 at 4:34pm',\n      customer: 'Jaydon Stanton',\n      total: '$969.44',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1019',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1019\n        </Text>\n      ),\n      date: 'Jul 20 at 3:46pm',\n      customer: 'Ruben Westerfelt',\n      total: '$701.19',\n      paymentStatus: <Badge progress=\"partiallyComplete\">Partially paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1018',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1018\n        </Text>\n      ),\n      date: 'Jul 20 at 3.44pm',\n      customer: 'Leo Carder',\n      total: '$798.24',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n  ];\n  const resourceName = {\n    singular: 'order',\n    plural: 'orders',\n  };\n\n  const {selectedResources, allResourcesSelected, handleSelectionChange} =\n    useIndexResourceState(orders);\n\n  const rowMarkup = orders.map(\n    (\n      {id, order, date, customer, total, paymentStatus, fulfillmentStatus},\n      index,\n    ) => (\n      <IndexTable.Row\n        id={id}\n        key={id}\n        selected={selectedResources.includes(id)}\n        position={index}\n      >\n        <IndexTable.Cell>\n          <Text variant=\"bodyMd\" fontWeight=\"bold\" as=\"span\">\n            {order}\n          </Text>\n        </IndexTable.Cell>\n        <IndexTable.Cell>{date}</IndexTable.Cell>\n        <IndexTable.Cell>{customer}</IndexTable.Cell>\n        <IndexTable.Cell>{total}</IndexTable.Cell>\n        <IndexTable.Cell>{paymentStatus}</IndexTable.Cell>\n        <IndexTable.Cell>{fulfillmentStatus}</IndexTable.Cell>\n      </IndexTable.Row>\n    ),\n  );\n\n  return (\n    <LegacyCard>\n      <IndexFilters\n        sortOptions={sortOptions}\n        sortSelected={sortSelected}\n        queryValue={queryValue}\n        queryPlaceholder=\"Searching in all\"\n        onQueryChange={handleFiltersQueryChange}\n        onQueryClear={() => setQueryValue('')}\n        onSort={setSortSelected}\n        primaryAction={primaryAction}\n        cancelAction={{\n          onAction: onHandleCancel,\n          disabled: false,\n          loading: false,\n        }}\n        tabs={tabs}\n        selected={selected}\n        onSelect={setSelected}\n        canCreateNewView\n        onCreateNewView={onCreateNewView}\n        filters={filters}\n        appliedFilters={appliedFilters}\n        onClearAll={handleFiltersClearAll}\n        mode={mode}\n        setMode={setMode}\n        disabled\n      />\n      <IndexTable\n        resourceName={resourceName}\n        itemCount={orders.length}\n        selectedItemsCount={\n          allResourcesSelected ? 'All' : selectedResources.length\n        }\n        onSelectionChange={handleSelectionChange}\n        headings={[\n          {title: 'Order'},\n          {title: 'Date'},\n          {title: 'Customer'},\n          {title: 'Total', alignment: 'end'},\n          {title: 'Payment status'},\n          {title: 'Fulfillment status'},\n        ]}\n      >\n        {rowMarkup}\n      </IndexTable>\n    </LegacyCard>\n  );\n\n  function disambiguateLabel(key: string, value: string | any[]): string {\n    switch (key) {\n      case 'moneySpent':\n        return `Money spent is between $${value[0]} and $${value[1]}`;\n      case 'taggedWith':\n        return `Tagged with ${value}`;\n      case 'accountStatus':\n        return (value as string[]).map((val) => `Customer ${val}`).join(', ');\n      default:\n        return value as string;\n    }\n  }\n\n  function isEmpty(value: string | any[]) {\n    if (Array.isArray(value)) {\n      return value.length === 0;\n    } else {\n      return value === '' || value == null;\n    }\n  }\n}\n\n"},{"fileName":"index-filters-with-no-filters.tsx","title":"With no filters","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"An IndexFilters component with only view management, search, and sorting.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {\n  IndexTable,\n  LegacyCard,\n  IndexFilters,\n  useSetIndexFiltersMode,\n  useIndexResourceState,\n  Text,\n  Badge,\n} from '@shopify/polaris';\nimport type {IndexFiltersProps, TabProps} from '@shopify/polaris';\nimport {useState, useCallback} from 'react';\n\nfunction IndexFiltersWithNoFiltersExample() {\n  const sleep = (ms: number) =>\n    new Promise((resolve) => setTimeout(resolve, ms));\n  const [itemStrings, setItemStrings] = useState([\n    'All',\n    'Unpaid',\n    'Open',\n    'Closed',\n    'Local delivery',\n    'Local pickup',\n  ]);\n  const deleteView = (index: number) => {\n    const newItemStrings = [...itemStrings];\n    newItemStrings.splice(index, 1);\n    setItemStrings(newItemStrings);\n    setSelected(0);\n  };\n\n  const duplicateView = async (name: string) => {\n    setItemStrings([...itemStrings, name]);\n    setSelected(itemStrings.length);\n    await sleep(1);\n    return true;\n  };\n\n  const tabs: TabProps[] = itemStrings.map((item, index) => ({\n    content: item,\n    index,\n    onAction: () => {},\n    id: `${item}-${index}`,\n    isLocked: index === 0,\n    actions:\n      index === 0\n        ? []\n        : [\n            {\n              type: 'rename',\n              onAction: () => {},\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                const newItemsStrings = tabs.map((item, idx) => {\n                  if (idx === index) {\n                    return value;\n                  }\n                  return item.content;\n                });\n                await sleep(1);\n                setItemStrings(newItemsStrings);\n                return true;\n              },\n            },\n            {\n              type: 'duplicate',\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                await sleep(1);\n                duplicateView(value);\n                return true;\n              },\n            },\n            {\n              type: 'edit',\n            },\n            {\n              type: 'delete',\n              onPrimaryAction: async () => {\n                await sleep(1);\n                deleteView(index);\n                return true;\n              },\n            },\n          ],\n  }));\n  const [selected, setSelected] = useState(0);\n  const onCreateNewView = async (value: string) => {\n    await sleep(500);\n    setItemStrings([...itemStrings, value]);\n    setSelected(itemStrings.length);\n    return true;\n  };\n  const sortOptions: IndexFiltersProps['sortOptions'] = [\n    {label: 'Order', value: 'order asc', directionLabel: 'Ascending'},\n    {label: 'Order', value: 'order desc', directionLabel: 'Descending'},\n    {label: 'Customer', value: 'customer asc', directionLabel: 'A-Z'},\n    {label: 'Customer', value: 'customer desc', directionLabel: 'Z-A'},\n    {label: 'Date', value: 'date asc', directionLabel: 'A-Z'},\n    {label: 'Date', value: 'date desc', directionLabel: 'Z-A'},\n    {label: 'Total', value: 'total asc', directionLabel: 'Ascending'},\n    {label: 'Total', value: 'total desc', directionLabel: 'Descending'},\n  ];\n  const [sortSelected, setSortSelected] = useState(['order asc']);\n  const {mode, setMode} = useSetIndexFiltersMode();\n  const onHandleCancel = () => {};\n\n  const onHandleSave = async () => {\n    await sleep(1);\n    return true;\n  };\n\n  const primaryAction: IndexFiltersProps['primaryAction'] =\n    selected === 0\n      ? {\n          type: 'save-as',\n          onAction: onCreateNewView,\n          disabled: false,\n          loading: false,\n        }\n      : {\n          type: 'save',\n          onAction: onHandleSave,\n          disabled: false,\n          loading: false,\n        };\n  const [queryValue, setQueryValue] = useState('');\n\n  const handleFiltersQueryChange = useCallback(\n    (value: string) => setQueryValue(value),\n    [],\n  );\n\n  const orders = [\n    {\n      id: '1020',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1020\n        </Text>\n      ),\n      date: 'Jul 20 at 4:34pm',\n      customer: 'Jaydon Stanton',\n      total: '$969.44',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1019',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1019\n        </Text>\n      ),\n      date: 'Jul 20 at 3:46pm',\n      customer: 'Ruben Westerfelt',\n      total: '$701.19',\n      paymentStatus: <Badge progress=\"partiallyComplete\">Partially paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1018',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1018\n        </Text>\n      ),\n      date: 'Jul 20 at 3.44pm',\n      customer: 'Leo Carder',\n      total: '$798.24',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n  ];\n  const resourceName = {\n    singular: 'order',\n    plural: 'orders',\n  };\n\n  const {selectedResources, allResourcesSelected, handleSelectionChange} =\n    useIndexResourceState(orders);\n\n  const rowMarkup = orders.map(\n    (\n      {id, order, date, customer, total, paymentStatus, fulfillmentStatus},\n      index,\n    ) => (\n      <IndexTable.Row\n        id={id}\n        key={id}\n        selected={selectedResources.includes(id)}\n        position={index}\n      >\n        <IndexTable.Cell>\n          <Text variant=\"bodyMd\" fontWeight=\"bold\" as=\"span\">\n            {order}\n          </Text>\n        </IndexTable.Cell>\n        <IndexTable.Cell>{date}</IndexTable.Cell>\n        <IndexTable.Cell>{customer}</IndexTable.Cell>\n        <IndexTable.Cell>{total}</IndexTable.Cell>\n        <IndexTable.Cell>{paymentStatus}</IndexTable.Cell>\n        <IndexTable.Cell>{fulfillmentStatus}</IndexTable.Cell>\n      </IndexTable.Row>\n    ),\n  );\n\n  return (\n    <LegacyCard>\n      <IndexFilters\n        sortOptions={sortOptions}\n        sortSelected={sortSelected}\n        queryValue={queryValue}\n        queryPlaceholder=\"Searching in all\"\n        onQueryChange={handleFiltersQueryChange}\n        onQueryClear={() => setQueryValue('')}\n        onSort={setSortSelected}\n        primaryAction={primaryAction}\n        cancelAction={{\n          onAction: onHandleCancel,\n          disabled: false,\n          loading: false,\n        }}\n        tabs={tabs}\n        selected={selected}\n        onSelect={setSelected}\n        canCreateNewView\n        onCreateNewView={onCreateNewView}\n        filters={[]}\n        appliedFilters={[]}\n        onClearAll={() => {}}\n        mode={mode}\n        setMode={setMode}\n        hideFilters\n        filteringAccessibilityTooltip=\"Search (F)\"\n      />\n      <IndexTable\n        resourceName={resourceName}\n        itemCount={orders.length}\n        selectedItemsCount={\n          allResourcesSelected ? 'All' : selectedResources.length\n        }\n        onSelectionChange={handleSelectionChange}\n        headings={[\n          {title: 'Order'},\n          {title: 'Date'},\n          {title: 'Customer'},\n          {title: 'Total', alignment: 'end'},\n          {title: 'Payment status'},\n          {title: 'Fulfillment status'},\n        ]}\n      >\n        {rowMarkup}\n      </IndexTable>\n    </LegacyCard>\n  );\n}\n\n"},{"fileName":"index-filters-with-no-search-or-filters.tsx","title":"With no search or filters","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"An IndexFilters component with only view management and sorting.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {\n  IndexTable,\n  LegacyCard,\n  IndexFilters,\n  useSetIndexFiltersMode,\n  useIndexResourceState,\n  Text,\n  Badge,\n} from '@shopify/polaris';\nimport type {IndexFiltersProps, TabProps} from '@shopify/polaris';\nimport {useState} from 'react';\n\nfunction IndexFiltersWithNoSearchOrFiltersExample() {\n  const sleep = (ms: number) =>\n    new Promise((resolve) => setTimeout(resolve, ms));\n  const [itemStrings, setItemStrings] = useState([\n    'All',\n    'Unpaid',\n    'Open',\n    'Closed',\n    'Local delivery',\n    'Local pickup',\n  ]);\n  const deleteView = (index: number) => {\n    const newItemStrings = [...itemStrings];\n    newItemStrings.splice(index, 1);\n    setItemStrings(newItemStrings);\n    setSelected(0);\n  };\n\n  const duplicateView = async (name: string) => {\n    setItemStrings([...itemStrings, name]);\n    setSelected(itemStrings.length);\n    await sleep(1);\n    return true;\n  };\n\n  const tabs: TabProps[] = itemStrings.map((item, index) => ({\n    content: item,\n    index,\n    onAction: () => {},\n    id: `${item}-${index}`,\n    isLocked: index === 0,\n    actions:\n      index === 0\n        ? []\n        : [\n            {\n              type: 'rename',\n              onAction: () => {},\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                const newItemsStrings = tabs.map((item, idx) => {\n                  if (idx === index) {\n                    return value;\n                  }\n                  return item.content;\n                });\n                await sleep(1);\n                setItemStrings(newItemsStrings);\n                return true;\n              },\n            },\n            {\n              type: 'duplicate',\n              onPrimaryAction: async (value: string): Promise<boolean> => {\n                await sleep(1);\n                duplicateView(value);\n                return true;\n              },\n            },\n            {\n              type: 'edit',\n            },\n            {\n              type: 'delete',\n              onPrimaryAction: async () => {\n                await sleep(1);\n                deleteView(index);\n                return true;\n              },\n            },\n          ],\n  }));\n  const [selected, setSelected] = useState(0);\n  const onCreateNewView = async (value: string) => {\n    await sleep(500);\n    setItemStrings([...itemStrings, value]);\n    setSelected(itemStrings.length);\n    return true;\n  };\n  const sortOptions: IndexFiltersProps['sortOptions'] = [\n    {label: 'Order', value: 'order asc', directionLabel: 'Ascending'},\n    {label: 'Order', value: 'order desc', directionLabel: 'Descending'},\n    {label: 'Customer', value: 'customer asc', directionLabel: 'A-Z'},\n    {label: 'Customer', value: 'customer desc', directionLabel: 'Z-A'},\n    {label: 'Date', value: 'date asc', directionLabel: 'A-Z'},\n    {label: 'Date', value: 'date desc', directionLabel: 'Z-A'},\n    {label: 'Total', value: 'total asc', directionLabel: 'Ascending'},\n    {label: 'Total', value: 'total desc', directionLabel: 'Descending'},\n  ];\n  const [sortSelected, setSortSelected] = useState(['order asc']);\n  const {mode, setMode} = useSetIndexFiltersMode();\n  const onHandleCancel = () => {};\n\n  const onHandleSave = async () => {\n    await sleep(1);\n    return true;\n  };\n\n  const primaryAction: IndexFiltersProps['primaryAction'] =\n    selected === 0\n      ? {\n          type: 'save-as',\n          onAction: onCreateNewView,\n          disabled: false,\n          loading: false,\n        }\n      : {\n          type: 'save',\n          onAction: onHandleSave,\n          disabled: false,\n          loading: false,\n        };\n\n  const orders = [\n    {\n      id: '1020',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1020\n        </Text>\n      ),\n      date: 'Jul 20 at 4:34pm',\n      customer: 'Jaydon Stanton',\n      total: '$969.44',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1019',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1019\n        </Text>\n      ),\n      date: 'Jul 20 at 3:46pm',\n      customer: 'Ruben Westerfelt',\n      total: '$701.19',\n      paymentStatus: <Badge progress=\"partiallyComplete\">Partially paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n    {\n      id: '1018',\n      order: (\n        <Text as=\"span\" variant=\"bodyMd\" fontWeight=\"semibold\">\n          #1018\n        </Text>\n      ),\n      date: 'Jul 20 at 3.44pm',\n      customer: 'Leo Carder',\n      total: '$798.24',\n      paymentStatus: <Badge progress=\"complete\">Paid</Badge>,\n      fulfillmentStatus: <Badge progress=\"incomplete\">Unfulfilled</Badge>,\n    },\n  ];\n  const resourceName = {\n    singular: 'order',\n    plural: 'orders',\n  };\n\n  const {selectedResources, allResourcesSelected, handleSelectionChange} =\n    useIndexResourceState(orders);\n\n  const rowMarkup = orders.map(\n    (\n      {id, order, date, customer, total, paymentStatus, fulfillmentStatus},\n      index,\n    ) => (\n      <IndexTable.Row\n        id={id}\n        key={id}\n        selected={selectedResources.includes(id)}\n        position={index}\n      >\n        <IndexTable.Cell>\n          <Text variant=\"bodyMd\" fontWeight=\"bold\" as=\"span\">\n            {order}\n          </Text>\n        </IndexTable.Cell>\n        <IndexTable.Cell>{date}</IndexTable.Cell>\n        <IndexTable.Cell>{customer}</IndexTable.Cell>\n        <IndexTable.Cell>{total}</IndexTable.Cell>\n        <IndexTable.Cell>{paymentStatus}</IndexTable.Cell>\n        <IndexTable.Cell>{fulfillmentStatus}</IndexTable.Cell>\n      </IndexTable.Row>\n    ),\n  );\n\n  return (\n    <LegacyCard>\n      <IndexFilters\n        sortOptions={sortOptions}\n        sortSelected={sortSelected}\n        queryValue=\"\"\n        queryPlaceholder=\"Searching in all\"\n        onQueryChange={() => {}}\n        onQueryClear={() => {}}\n        onSort={setSortSelected}\n        primaryAction={primaryAction}\n        cancelAction={{\n          onAction: onHandleCancel,\n          disabled: false,\n          loading: false,\n        }}\n        tabs={tabs}\n        selected={selected}\n        onSelect={setSelected}\n        canCreateNewView\n        onCreateNewView={onCreateNewView}\n        filters={[]}\n        appliedFilters={[]}\n        onClearAll={() => {}}\n        mode={mode}\n        setMode={setMode}\n        hideFilters\n        hideQueryField\n      />\n      <IndexTable\n        resourceName={resourceName}\n        itemCount={orders.length}\n        selectedItemsCount={\n          allResourcesSelected ? 'All' : selectedResources.length\n        }\n        onSelectionChange={handleSelectionChange}\n        headings={[\n          {title: 'Order'},\n          {title: 'Date'},\n          {title: 'Customer'},\n          {title: 'Total', alignment: 'end'},\n          {title: 'Payment status'},\n          {title: 'Fulfillment status'},\n        ]}\n      >\n        {rowMarkup}\n      </IndexTable>\n    </LegacyCard>\n  );\n}\n\n"}],"seoDescription":"Use index filters to allow merchants to filter, search, and sort their index table data and create unique saved views from the results.","type":{"IndexFiltersProps":{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","name":"IndexFiltersProps","description":"","members":[{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"sortOptions","value":"SortButtonChoice[]","description":"The available sorting choices. If not present, the sort button will not show","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"sortSelected","value":"string[]","description":"The currently selected sort choice. Required if using sorting","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"onSort","value":"(value: string[]) => void","description":"Optional callback invoked when a merchant changes the sort order. Required if using sorting","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"onSortKeyChange","value":"(value: string) => void","description":"Optional callback when using saved views and changing the sort key","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"onSortDirectionChange","value":"(value: string) => void","description":"Optional callback when using saved views and changing the sort direction","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"onAddFilterClick","value":"() => void","description":"Callback when the add filter button is clicked, to be passed to AlphaFilters.","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"primaryAction","value":"IndexFiltersPrimaryAction","description":"The primary action to display","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"cancelAction","value":"IndexFiltersCancelAction","description":"The cancel action to display"},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"onEditStart","value":"(mode: ActionableIndexFiltersMode) => void","description":"Optional callback invoked when a merchant begins to edit a view","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"mode","value":"IndexFiltersMode","description":"The current mode of the IndexFilters component. Used to determine which view to show"},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"setMode","value":"(mode: IndexFiltersMode) => void","description":"Callback to set the mode of the IndexFilters component"},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"disabled","value":"boolean","description":"Will disable all the elements within the IndexFilters component","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"disableQueryField","value":"boolean","description":"Will disable just the query field","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"disableStickyMode","value":"boolean","description":"If true, the sticky interaction on smaller devices will be disabled","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"isFlushWhenSticky","value":"boolean","description":"If the component should go flush to the top of the page when sticking","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"canCreateNewView","value":"boolean","description":"Whether the index supports creating new views","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"onCreateNewView","value":"(name: string) => Promise<boolean>","description":"Callback invoked when a merchant creates a new view","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"filteringAccessibilityLabel","value":"string","description":"Optional override to the default aria-label for the button that toggles the filtering mode","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"filteringAccessibilityTooltip","value":"string","description":"Optional override to the default Tooltip message for the button that toggles the filtering mode","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"closeOnChildOverlayClick","value":"boolean","description":"Whether the filter should close when clicking inside another Popover.","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"disableKeyboardShortcuts","value":"boolean","description":"Optional override to the default keyboard shortcuts available","isOptional":true},{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"PropertySignature","name":"showEditColumnsButton","value":"boolean","description":"Whether to display the edit columns button with the other default mode filter actions","isOptional":true}],"value":"export interface IndexFiltersProps\n  extends Omit<\n      FiltersProps,\n      'focused' | 'children' | 'disableQueryField' | 'disableFilters'\n    >,\n    Pick<TabsProps, 'tabs' | 'onSelect' | 'selected'> {\n  /** The available sorting choices. If not present, the sort button will not show */\n  sortOptions?: SortButtonChoice[];\n  /** The currently selected sort choice. Required if using sorting */\n  sortSelected?: string[];\n  /** Optional callback invoked when a merchant changes the sort order. Required if using sorting */\n  onSort?: (value: string[]) => void;\n  /** Optional callback when using saved views and changing the sort key */\n  onSortKeyChange?: (value: string) => void;\n  /** Optional callback when using saved views and changing the sort direction */\n  onSortDirectionChange?: (value: string) => void;\n  /** Callback when the add filter button is clicked, to be passed to AlphaFilters. */\n  onAddFilterClick?: () => void;\n  /** The primary action to display  */\n  primaryAction?: IndexFiltersPrimaryAction;\n  /** The cancel action to display */\n  cancelAction: IndexFiltersCancelAction;\n  /** Optional callback invoked when a merchant begins to edit a view */\n  onEditStart?: (mode: ActionableIndexFiltersMode) => void;\n  /** The current mode of the IndexFilters component. Used to determine which view to show */\n  mode: IndexFiltersMode;\n  /** Callback to set the mode of the IndexFilters component */\n  setMode: (mode: IndexFiltersMode) => void;\n  /** Will disable all the elements within the IndexFilters component */\n  disabled?: boolean;\n  /** Will disable just the query field */\n  disableQueryField?: boolean;\n  /** If true, the sticky interaction on smaller devices will be disabled */\n  disableStickyMode?: boolean;\n  /** If the component should go flush to the top of the page when sticking */\n  isFlushWhenSticky?: boolean;\n  /** Whether the index supports creating new views */\n  canCreateNewView?: boolean;\n  /** Callback invoked when a merchant creates a new view */\n  onCreateNewView?: (name: string) => Promise<boolean>;\n  /** Optional override to the default aria-label for the button that toggles the filtering mode */\n  filteringAccessibilityLabel?: string;\n  /** Optional override to the default Tooltip message for the button that toggles the filtering mode */\n  filteringAccessibilityTooltip?: string;\n  /** Whether the filter should close when clicking inside another Popover. */\n  closeOnChildOverlayClick?: boolean;\n  /** Optional override to the default keyboard shortcuts available */\n  disableKeyboardShortcuts?: boolean;\n  /** Whether to display the edit columns button with the other default mode filter actions */\n  showEditColumnsButton?: boolean;\n}"},"SortButtonChoice":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","name":"SortButtonChoice","description":"","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"label","value":"string","description":""},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"disabled","value":"boolean","description":"","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"value","value":"`${string} asc` | `${string} desc`","description":""},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"directionLabel","value":"string","description":""}],"value":"export interface SortButtonChoice {\n  label: string;\n  disabled?: boolean;\n  value: SortValue;\n  directionLabel: string;\n}"},"IndexFiltersPrimaryAction":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","name":"IndexFiltersPrimaryAction","description":"","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"type","value":"\"save\" | \"save-as\" | \"cancel\"","description":""},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"onAction","value":"(name: string) => Promise<boolean>","description":""},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"disabled","value":"boolean","description":"","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"loading","value":"boolean","description":"","isOptional":true}],"value":"export interface IndexFiltersPrimaryAction {\n  type: 'save' | 'save-as' | 'cancel';\n  onAction: (name: string) => Promise<boolean>;\n  disabled?: boolean;\n  loading?: boolean;\n}"},"IndexFiltersCancelAction":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","name":"IndexFiltersCancelAction","description":"","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"onAction","value":"() => void","description":""},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"disabled","value":"boolean","description":"","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"PropertySignature","name":"loading","value":"boolean","description":"","isOptional":true}],"value":"export interface IndexFiltersCancelAction {\n  onAction: () => void;\n  disabled?: boolean;\n  loading?: boolean;\n}"},"ActionableIndexFiltersMode":{"filePath":"polaris-react/src/components/IndexFilters/IndexFilters.tsx","syntaxKind":"TypeAliasDeclaration","name":"ActionableIndexFiltersMode","value":"Exclude<\n  IndexFiltersMode,\n  IndexFiltersMode.Default\n>","description":""},"IndexFiltersMode":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","syntaxKind":"EnumDeclaration","name":"IndexFiltersMode","value":"export enum IndexFiltersMode {\n  Default = 'DEFAULT',\n  Filtering = 'FILTERING',\n  EditingColumns = 'EDITING_COLUMNS',\n}","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","name":"Default","value":"DEFAULT"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","name":"Filtering","value":"FILTERING"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/components/IndexFilters/types.ts","name":"EditingColumns","value":"EDITING_COLUMNS"}]}},"editPageLinkPath":"polaris.shopify.com/content/components/selection-and-input/index-filters.mdx"},"__N_SSG":true}