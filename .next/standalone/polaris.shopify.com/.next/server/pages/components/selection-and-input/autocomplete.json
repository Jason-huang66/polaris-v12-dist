{"pageProps":{"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    hr: \"hr\",\n    a: \"a\",\n    h3: \"h3\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {Lede, Examples, Props, DoDont} = _components;\n  if (!DoDont) _missingMdxReference(\"DoDont\", true);\n  if (!Examples) _missingMdxReference(\"Examples\", true);\n  if (!Lede) _missingMdxReference(\"Lede\", true);\n  if (!Props) _missingMdxReference(\"Props\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      id: \"frontmattertitle\",\n      children: frontmatter.title\n    }), \"\\n\", _jsx(Lede, {\n      children: _jsxs(_components.p, {\n        children: [\"The autocomplete component is an input field that provides selectable suggestions as a merchant types into it. It allows merchants to quickly search through and select from large collections of options. It's a convenience wrapper around the \", _jsx(_components.code, {\n          children: \"Combobox\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"Listbox\"\n        }), \" components with minor UI differences.\"]\n      })\n    }), \"\\n\", _jsx(Examples, {}), \"\\n\", _jsx(Props, {\n      componentName: frontmatter.title\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"best-practices\",\n      children: \"Best practices\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The autocomplete component should:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Be clearly labeled so it’s obvious to the merchant what type of options will be available\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Limit the number of options displayed at once\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Not be used within a popover\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Indicate a loading state to the merchant while option data is being populated\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"content-guidelines\",\n      children: \"Content guidelines\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The input field for autocomplete should follow the \", _jsx(_components.a, {\n        href: \"https://polaris.shopify.com/components/selection-and-input/text-field\",\n        children: \"content guidelines\"\n      }), \" for text fields.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"related-components\",\n      children: \"Related components\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"For an input field without suggested options, \", _jsx(_components.a, {\n          href: \"https://polaris.shopify.com/components/selection-and-input/text-field\",\n          children: \"use the text field component\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"For a list of selectable options not linked to an input field, \", _jsx(_components.a, {\n          href: \"https://polaris.shopify.com/components/option-list\",\n          children: \"use the option list component\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"For a text field that triggers a popover, \", _jsx(_components.a, {\n          href: \"https://polaris.shopify.com/components/combobox\",\n          children: \"use the combo box component\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"accessibility\",\n      children: \"Accessibility\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"structure\",\n      children: \"Structure\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The autocomplete component is based on the \", _jsx(_components.a, {\n        href: \"https://www.w3.org/TR/wai-aria-practices-1.1/#combobox\",\n        children: \"ARIA 1.2 combobox pattern\"\n      }), \" and the \", _jsx(_components.a, {\n        href: \"https://www.w3.org/TR/wai-aria-practices-1.2/#Listbox\",\n        children: \"Aria 1.2 Listbox pattern\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The autocomplete list displays below the text field or other control by default so it is easy for merchants to discover and use. However, you can change the position with the \", _jsx(_components.code, {\n        children: \"preferredPosition\"\n      }), \" prop.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Autocomplete features can be challenging for merchants with visual, motor, and cognitive disabilities. Even when they’re built using best practices, these features can be difficult to use with some assistive technologies. Merchants should always be able to search, enter data, or perform other activities without relying on the autocomplete.\"\n    }), \"\\n\", _jsxs(DoDont, {\n      children: [_jsx(_components.h4, {\n        id: \"do\",\n        children: \"Do\"\n      }), _jsx(_components.p, {\n        children: \"Use autocomplete as progressive enhancement to make the interface easier to use for most merchants.\"\n      }), _jsx(_components.h4, {\n        id: \"dont\",\n        children: \"Don’t\"\n      }), _jsx(_components.p, {\n        children: \"Require that merchants make a selection from the autocomplete to complete a task.\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"keyboard-support\",\n      children: \"Keyboard support\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Give the autocomplete text input keyboard focus with the \", _jsx(\"kbd\", {\n          children: \"tab\"\n        }), \" key (or \", _jsx(\"kbd\", {\n          children: \"shift\"\n        }), \" + \", _jsx(\"kbd\", {\n          children: \"tab\"\n        }), \" when tabbing backwards)\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Access the list of options with the up and down arrow keys\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Select an option that has focus with the \", _jsx(\"kbd\", {\n          children: \"enter\"\n        }), \"/\", _jsx(\"kbd\", {\n          children: \"return\"\n        }), \" key\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{"title":"Autocomplete","category":"Selection and input","keywords":["autocomplete","searchable","typeahead","combobox","listbox"],"examples":[{"fileName":"autocomplete-default.tsx","title":"Default","description":"Use to help merchants complete text input quickly from a list of options."},{"fileName":"autocomplete-with-multiple-tags.tsx","title":"With multiple tags","description":"Use to help merchants select multiple options from a list curated by the text input."},{"fileName":"autocomplete-with-multiple-sections.tsx","title":"With multiple sections","description":"Use to help merchants complete text input quickly from a multiple sections list of options."},{"fileName":"autocomplete-with-loading.tsx","title":"With loading","description":"Use to indicate loading state to merchants while option data is processing."},{"fileName":"autocomplete-with-lazy-loading.tsx","title":"With lazy loading"},{"fileName":"autocomplete-with-empty-state.tsx","title":"With empty state","description":"Use to indicate there are no search results."},{"fileName":"autocomplete-with-action.tsx","title":"With action","description":"Use to help merchants complete an action quickly."},{"fileName":"autocomplete-with-wrapping-action.tsx","title":"With wrapping action","description":"Use to help merchants complete an action quickly with wrapping lines of text."},{"fileName":"autocomplete-with-destructive-action.tsx","title":"With destructive action","description":"Use to help merchants complete a destructive action quickly."}],"previewImg":"/images/components/selection-and-input/autocomplete.png"},"scope":{"__remarkNextMdxImporter":{}}},"examples":[{"fileName":"autocomplete-default.tsx","title":"Default","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to help merchants complete text input quickly from a list of options.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon} from '@shopify/polaris';\nimport {SearchMinor} from '@shopify/polaris-icons';\nimport {useState, useCallback, useMemo} from 'react';\n\nfunction AutocompleteExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (value === '') {\n        setOptions(deselectedOptions);\n        return;\n      }\n\n      const filterRegex = new RegExp(value, 'i');\n      const resultOptions = deselectedOptions.filter((option) =>\n        option.label.match(filterRegex),\n      );\n      setOptions(resultOptions);\n    },\n    [deselectedOptions],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      const selectedValue = selected.map((selectedItem) => {\n        const matchedOption = options.find((option) => {\n          return option.value.match(selectedItem);\n        });\n        return matchedOption && matchedOption.label;\n      });\n\n      setSelectedOptions(selected);\n      setInputValue(selectedValue[0] || '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} tone=\"base\" />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        options={options}\n        selected={selectedOptions}\n        onSelect={updateSelection}\n        textField={textField}\n      />\n    </div>\n  );\n}\n\n"},{"fileName":"autocomplete-with-multiple-tags.tsx","title":"With multiple tags","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to help merchants select multiple options from a list curated by the text input.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {LegacyStack, Tag, Autocomplete} from '@shopify/polaris';\nimport {useState, useCallback, useMemo} from 'react';\n\nfunction MultiAutocompleteExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>(['rustic']);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (value === '') {\n        setOptions(deselectedOptions);\n        return;\n      }\n\n      const filterRegex = new RegExp(value, 'i');\n      const resultOptions = deselectedOptions.filter((option) =>\n        option.label.match(filterRegex),\n      );\n\n      setOptions(resultOptions);\n    },\n    [deselectedOptions],\n  );\n\n  const removeTag = useCallback(\n    (tag: string) => () => {\n      const options = [...selectedOptions];\n      options.splice(options.indexOf(tag), 1);\n      setSelectedOptions(options);\n    },\n    [selectedOptions],\n  );\n\n  const verticalContentMarkup =\n    selectedOptions.length > 0 ? (\n      <LegacyStack spacing=\"extraTight\" alignment=\"center\">\n        {selectedOptions.map((option) => {\n          let tagLabel = '';\n          tagLabel = option.replace('_', ' ');\n          tagLabel = titleCase(tagLabel);\n          return (\n            <Tag key={`option${option}`} onRemove={removeTag(option)}>\n              {tagLabel}\n            </Tag>\n          );\n        })}\n      </LegacyStack>\n    ) : null;\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      placeholder=\"Vintage, cotton, summer\"\n      verticalContent={verticalContentMarkup}\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '325px'}}>\n      <Autocomplete\n        allowMultiple\n        options={options}\n        selected={selectedOptions}\n        textField={textField}\n        onSelect={setSelectedOptions}\n        listTitle=\"Suggested Tags\"\n      />\n    </div>\n  );\n\n  function titleCase(string: string) {\n    return string\n      .toLowerCase()\n      .split(' ')\n      .map((word) => word.replace(word[0], word[0].toUpperCase()))\n      .join('');\n  }\n}\n\n"},{"fileName":"autocomplete-with-multiple-sections.tsx","title":"With multiple sections","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to help merchants complete text input quickly from a multiple sections list of options.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon} from '@shopify/polaris';\nimport {SearchMinor} from '@shopify/polaris-icons';\nimport {useState, useCallback, useMemo} from 'react';\n\ntype Section = {\n  title: string;\n  options: {\n    value: string;\n    label: string;\n  }[];\n};\n\nfunction AutocompleteExample() {\n  const deselectedOptions = useMemo(\n    (): Section[] => [\n      {\n        title: 'Frequently used',\n        options: [\n          {value: 'ups', label: 'UPS'},\n          {value: 'usps', label: 'USPS'},\n        ],\n      },\n      {\n        title: 'All carriers',\n        options: [\n          {value: 'dhl', label: 'DHL Express'},\n          {value: 'canada_post', label: 'Canada Post'},\n        ],\n      },\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (value === '') {\n        setOptions(deselectedOptions);\n        return;\n      }\n\n      const filterRegex = new RegExp(value, 'i');\n      const resultOptions: Section[] = [];\n\n      deselectedOptions.forEach((opt) => {\n        const options = opt.options.filter((option) =>\n          option.label.match(filterRegex),\n        );\n\n        resultOptions.push({\n          title: opt.title,\n          options,\n        });\n      });\n\n      setOptions(resultOptions);\n    },\n    [deselectedOptions],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      let selectedValue: string | undefined;\n\n      options.forEach(({options}) => {\n        if (selectedValue) {\n          return;\n        }\n\n        const matchedOption = options.find((option) =>\n          option.value.match(selected[0]),\n        );\n\n        if (matchedOption) {\n          selectedValue = matchedOption.label;\n        }\n      });\n\n      setSelectedOptions(selected);\n      setInputValue(selectedValue ? selectedValue : '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} tone=\"base\" />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        textField={textField}\n        selected={selectedOptions}\n        options={options}\n        onSelect={updateSelection}\n      />\n    </div>\n  );\n}\n\n"},{"fileName":"autocomplete-with-loading.tsx","title":"With loading","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to indicate loading state to merchants while option data is processing.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon} from '@shopify/polaris';\nimport {SearchMinor} from '@shopify/polaris-icons';\nimport {useState, useCallback, useMemo} from 'react';\n\nfunction AutocompleteExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n  const [loading, setLoading] = useState(false);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (!loading) {\n        setLoading(true);\n      }\n\n      setTimeout(() => {\n        if (value === '') {\n          setOptions(deselectedOptions);\n          setLoading(false);\n          return;\n        }\n        const filterRegex = new RegExp(value, 'i');\n        const resultOptions = deselectedOptions.filter((option) =>\n          option.label.match(filterRegex),\n        );\n        setOptions(resultOptions);\n        setLoading(false);\n      }, 300);\n    },\n    [deselectedOptions, loading],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      const selectedText = selected.map((selectedItem) => {\n        const matchedOption = options.find((option) => {\n          return option.value.match(selectedItem);\n        });\n        return matchedOption && matchedOption.label;\n      });\n      setSelectedOptions(selected);\n      setInputValue(selectedText[0] || '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} tone=\"base\" />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        options={options}\n        selected={selectedOptions}\n        onSelect={updateSelection}\n        loading={loading}\n        textField={textField}\n      />\n    </div>\n  );\n}\n\n"},{"fileName":"autocomplete-with-lazy-loading.tsx","title":"With lazy loading","description":null,"code":"import {Autocomplete, Tag, LegacyStack} from '@shopify/polaris';\nimport {useState, useCallback} from 'react';\n\nfunction AutoCompleteLazyLoadExample() {\n  const paginationInterval = 25;\n  const deselectedOptions = Array.from(Array(100)).map((_, index) => ({\n    value: `rustic ${index + 1}`,\n    label: `Rustic ${index + 1}`,\n  }));\n\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n  const [isLoading, setIsLoading] = useState(false);\n  const [willLoadMoreResults, setWillLoadMoreResults] = useState(true);\n  const [visibleOptionIndex, setVisibleOptionIndex] =\n    useState(paginationInterval);\n\n  const handleLoadMoreResults = useCallback(() => {\n    if (willLoadMoreResults) {\n      setIsLoading(true);\n\n      setTimeout(() => {\n        const remainingOptionCount = options.length - visibleOptionIndex;\n        const nextVisibleOptionIndex =\n          remainingOptionCount >= paginationInterval\n            ? visibleOptionIndex + paginationInterval\n            : visibleOptionIndex + remainingOptionCount;\n\n        setIsLoading(false);\n        setVisibleOptionIndex(nextVisibleOptionIndex);\n\n        if (remainingOptionCount <= paginationInterval) {\n          setWillLoadMoreResults(false);\n        }\n      }, 1000);\n    }\n  }, [willLoadMoreResults, visibleOptionIndex, options.length]);\n\n  const removeTag = useCallback(\n    (tag: string) => () => {\n      const options = [...selectedOptions];\n      options.splice(options.indexOf(tag), 1);\n      setSelectedOptions(options);\n    },\n    [selectedOptions],\n  );\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (value === '') {\n        setOptions(deselectedOptions);\n        return;\n      }\n\n      const filterRegex = new RegExp(value, 'i');\n      const resultOptions = deselectedOptions.filter((option) =>\n        option.label.match(filterRegex),\n      );\n\n      setOptions(resultOptions);\n      setInputValue;\n    },\n    [deselectedOptions],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      placeholder=\"Vintage, cotton, summer\"\n      autoComplete=\"off\"\n    />\n  );\n\n  const hasSelectedOptions = selectedOptions.length > 0;\n\n  const tagsMarkup = hasSelectedOptions\n    ? selectedOptions.map((option) => {\n        let tagLabel = '';\n        tagLabel = option.replace('_', ' ');\n        tagLabel = titleCase(tagLabel);\n        return (\n          <Tag key={`option${option}`} onRemove={removeTag(option)}>\n            {tagLabel}\n          </Tag>\n        );\n      })\n    : null;\n  const optionList = options.slice(0, visibleOptionIndex);\n  const selectedTagMarkup = hasSelectedOptions ? (\n    <LegacyStack spacing=\"extraTight\">{tagsMarkup}</LegacyStack>\n  ) : null;\n\n  return (\n    <LegacyStack vertical>\n      {selectedTagMarkup}\n      <Autocomplete\n        allowMultiple\n        options={optionList}\n        selected={selectedOptions}\n        textField={textField}\n        onSelect={setSelectedOptions}\n        listTitle=\"Suggested Tags\"\n        loading={isLoading}\n        onLoadMoreResults={handleLoadMoreResults}\n        willLoadMoreResults={willLoadMoreResults}\n      />\n    </LegacyStack>\n  );\n\n  function titleCase(string: string) {\n    return string\n      .toLowerCase()\n      .split(' ')\n      .map((word) => {\n        return word.replace(word[0], word[0].toUpperCase());\n      })\n      .join(' ');\n  }\n}\n\n"},{"fileName":"autocomplete-with-empty-state.tsx","title":"With empty state","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to indicate there are no search results.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon, TextContainer} from '@shopify/polaris';\nimport {SearchMinor} from '@shopify/polaris-icons';\nimport React, {useState, useCallback, useMemo} from 'react';\n\nfunction AutocompleteExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n  const [loading, setLoading] = useState(false);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (!loading) {\n        setLoading(true);\n      }\n\n      setTimeout(() => {\n        if (value === '') {\n          setOptions(deselectedOptions);\n          setLoading(false);\n          return;\n        }\n        const filterRegex = new RegExp(value, 'i');\n        const resultOptions = deselectedOptions.filter((option) =>\n          option.label.match(filterRegex),\n        );\n        setOptions(resultOptions);\n        setLoading(false);\n      }, 300);\n    },\n    [deselectedOptions, loading],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      const selectedText = selected.map((selectedItem) => {\n        const matchedOption = options.find((option) => {\n          return option.value.match(selectedItem);\n        });\n        return matchedOption && matchedOption.label;\n      });\n      setSelectedOptions(selected);\n      setInputValue(selectedText[0] || '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} tone=\"base\" />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  const emptyState = (\n    <React.Fragment>\n      <Icon source={SearchMinor} />\n      <div style={{textAlign: 'center'}}>\n        <TextContainer>Could not find any results</TextContainer>\n      </div>\n    </React.Fragment>\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        options={options}\n        selected={selectedOptions}\n        onSelect={updateSelection}\n        emptyState={emptyState}\n        loading={loading}\n        textField={textField}\n      />\n    </div>\n  );\n}\n\n"},{"fileName":"autocomplete-with-action.tsx","title":"With action","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to help merchants complete an action quickly.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon} from '@shopify/polaris';\nimport {SearchMinor, CirclePlusMinor} from '@shopify/polaris-icons';\nimport {useState, useCallback, useMemo} from 'react';\n\nfunction AutocompleteActionBeforeExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n  const [loading, setLoading] = useState(false);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (!loading) {\n        setLoading(true);\n      }\n\n      setTimeout(() => {\n        if (value === '') {\n          setOptions(deselectedOptions);\n          setLoading(false);\n          return;\n        }\n        const filterRegex = new RegExp(value, 'i');\n        const resultOptions = options.filter((option) =>\n          option.label.match(filterRegex),\n        );\n        setOptions(resultOptions);\n        setLoading(false);\n      }, 300);\n    },\n    [deselectedOptions, loading, options],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      const selectedText = selected.map((selectedItem) => {\n        const matchedOption = options.find((option) => {\n          return option.value.match(selectedItem);\n        });\n        return matchedOption && matchedOption.label;\n      });\n      setSelectedOptions(selected);\n      setInputValue(selectedText[0] || '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        actionBefore={{\n          accessibilityLabel: 'Action label',\n          badge: {\n            tone: 'new',\n            content: 'New!',\n          },\n          content: 'Action with long name',\n          ellipsis: true,\n          helpText: 'Help text',\n          icon: CirclePlusMinor,\n          onAction: () => {\n            console.log('actionBefore clicked!');\n          },\n        }}\n        options={options}\n        selected={selectedOptions}\n        onSelect={updateSelection}\n        listTitle=\"Suggested tags\"\n        loading={loading}\n        textField={textField}\n      />\n    </div>\n  );\n}\n\n"},{"fileName":"autocomplete-with-wrapping-action.tsx","title":"With wrapping action","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to help merchants complete an action quickly with wrapping lines of text.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon} from '@shopify/polaris';\nimport {SearchMinor, CirclePlusMinor} from '@shopify/polaris-icons';\nimport {useState, useCallback, useMemo} from 'react';\n\nfunction AutocompleteActionBeforeExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n  const [loading, setLoading] = useState(false);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (!loading) {\n        setLoading(true);\n      }\n\n      setTimeout(() => {\n        if (value === '') {\n          setOptions(deselectedOptions);\n          setLoading(false);\n          return;\n        }\n        const filterRegex = new RegExp(value, 'i');\n        const resultOptions = options.filter((option) =>\n          option.label.match(filterRegex),\n        );\n        setOptions(resultOptions);\n        setLoading(false);\n      }, 300);\n    },\n    [deselectedOptions, loading, options],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      const selectedText = selected.map((selectedItem) => {\n        const matchedOption = options.find((option) => {\n          return option.value.match(selectedItem);\n        });\n        return matchedOption && matchedOption.label;\n      });\n      setSelectedOptions(selected);\n      setInputValue(selectedText[0] || '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        actionBefore={{\n          accessibilityLabel: 'Action label',\n          badge: {\n            tone: 'new',\n            content: 'New!',\n          },\n          content:\n            'Action with long name that will need to wrap on small display in order to have a nice display',\n          ellipsis: true,\n          helpText: 'Help text',\n          icon: CirclePlusMinor,\n          wrapOverflow: true,\n          onAction: () => {\n            console.log('actionBefore clicked!');\n          },\n        }}\n        options={options}\n        selected={selectedOptions}\n        onSelect={updateSelection}\n        listTitle=\"Suggested tags\"\n        loading={loading}\n        textField={textField}\n      />\n    </div>\n  );\n}\n\n"},{"fileName":"autocomplete-with-destructive-action.tsx","title":"With destructive action","description":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Use to help merchants complete a destructive action quickly.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"__remarkNextMdxImporter":{}}},"code":"import {Autocomplete, Icon} from '@shopify/polaris';\nimport {SearchMinor, DeleteMinor} from '@shopify/polaris-icons';\nimport {useState, useCallback, useMemo} from 'react';\n\nfunction AutocompleteActionBeforeExample() {\n  const deselectedOptions = useMemo(\n    () => [\n      {value: 'rustic', label: 'Rustic'},\n      {value: 'antique', label: 'Antique'},\n      {value: 'vinyl', label: 'Vinyl'},\n      {value: 'vintage', label: 'Vintage'},\n      {value: 'refurbished', label: 'Refurbished'},\n    ],\n    [],\n  );\n  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);\n  const [inputValue, setInputValue] = useState('');\n  const [options, setOptions] = useState(deselectedOptions);\n  const [loading, setLoading] = useState(false);\n\n  const updateText = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      if (!loading) {\n        setLoading(true);\n      }\n\n      setTimeout(() => {\n        if (value === '') {\n          setOptions(deselectedOptions);\n          setLoading(false);\n          return;\n        }\n        const filterRegex = new RegExp(value, 'i');\n        const resultOptions = options.filter((option) =>\n          option.label.match(filterRegex),\n        );\n        setOptions(resultOptions);\n        setLoading(false);\n      }, 300);\n    },\n    [deselectedOptions, loading, options],\n  );\n\n  const updateSelection = useCallback(\n    (selected: string[]) => {\n      const selectedText = selected.map((selectedItem) => {\n        const matchedOption = options.find((option) => {\n          return option.value.match(selectedItem);\n        });\n        return matchedOption && matchedOption.label;\n      });\n      setSelectedOptions(selected);\n      setInputValue(selectedText[0] || '');\n    },\n    [options],\n  );\n\n  const textField = (\n    <Autocomplete.TextField\n      onChange={updateText}\n      label=\"Tags\"\n      value={inputValue}\n      prefix={<Icon source={SearchMinor} />}\n      placeholder=\"Search\"\n      autoComplete=\"off\"\n    />\n  );\n\n  return (\n    <div style={{height: '225px'}}>\n      <Autocomplete\n        actionBefore={{\n          accessibilityLabel: 'Destructive action label',\n          content: 'Destructive action',\n          destructive: true,\n          icon: DeleteMinor,\n          onAction: () => {\n            console.log('actionBefore clicked!');\n          },\n        }}\n        options={options}\n        selected={selectedOptions}\n        onSelect={updateSelection}\n        listTitle=\"Suggested tags\"\n        loading={loading}\n        textField={textField}\n      />\n    </div>\n  );\n}\n\n"}],"seoDescription":"The autocomplete component is an input field that provides selectable suggestions as a merchant types into it. It allows merchants to quickly search through and select from large collections of options. It's a convenience wrapper around the Combobox and Listbox components with minor UI differences.","type":{"AutocompleteProps":{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","name":"AutocompleteProps","description":"","members":[{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"id","value":"string","description":"A unique identifier for the Autocomplete","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"options","value":"OptionDescriptor[] | SectionDescriptor[]","description":"Collection of options to be listed"},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"selected","value":"string[]","description":"The selected options"},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"textField","value":"React.ReactElement","description":"The text field component attached to the list of options"},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"preferredPosition","value":"PreferredPosition","description":"The preferred direction to open the popover","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"listTitle","value":"string","description":"Title of the list of options","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"allowMultiple","value":"boolean","description":"Allow more than one option to be selected","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"actionBefore","value":"ActionListItemDescriptor & { wrapOverflow?: boolean; }","description":"An action to render above the list of options","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"loading","value":"boolean","description":"Display loading state","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"willLoadMoreResults","value":"boolean","description":"Indicates if more results will load dynamically","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"PropertySignature","name":"emptyState","value":"React.ReactNode","description":"Is rendered when there are no options","isOptional":true},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"MethodSignature","name":"onSelect","value":"(selected: string[]) => void","description":"Callback when the selection of options is changed"},{"filePath":"polaris-react/src/components/Autocomplete/Autocomplete.tsx","syntaxKind":"MethodSignature","name":"onLoadMoreResults","value":"() => void","description":"Callback when the end of the list is reached","isOptional":true}],"value":"export interface AutocompleteProps {\n  /** A unique identifier for the Autocomplete */\n  id?: string;\n  /** Collection of options to be listed */\n  options: SectionDescriptor[] | OptionDescriptor[];\n  /** The selected options */\n  selected: string[];\n  /** The text field component attached to the list of options */\n  textField: React.ReactElement;\n  /** The preferred direction to open the popover */\n  preferredPosition?: PopoverProps['preferredPosition'];\n  /** Title of the list of options */\n  listTitle?: string;\n  /** Allow more than one option to be selected */\n  allowMultiple?: boolean;\n  /** An action to render above the list of options */\n  actionBefore?: ActionListItemDescriptor & {\n    /** Specifies that if the label is too long it will wrap instead of being hidden  */\n    wrapOverflow?: boolean;\n  };\n  /** Display loading state */\n  loading?: boolean;\n  /** Indicates if more results will load dynamically */\n  willLoadMoreResults?: boolean;\n  /** Is rendered when there are no options */\n  emptyState?: React.ReactNode;\n  /** Callback when the selection of options is changed */\n  onSelect(selected: string[]): void;\n  /** Callback when the end of the list is reached */\n  onLoadMoreResults?(): void;\n}"},"OptionDescriptor":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","name":"OptionDescriptor","description":"","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"value","value":"string","description":"Value of the option"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"label","value":"React.ReactNode","description":"Display label for the option"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"disabled","value":"boolean","description":"Whether the option is disabled or not","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"active","value":"boolean","description":"Whether the option is active or not","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"id","value":"string","description":"Unique identifier for the option","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"media","value":"React.ReactElement<IconProps | ThumbnailProps | AvatarProps>","description":"Media to display to the left of the option content","isOptional":true}],"value":"export interface OptionDescriptor {\n  /** Value of the option */\n  value: string;\n  /** Display label for the option */\n  label: React.ReactNode;\n  /** Whether the option is disabled or not */\n  disabled?: boolean;\n  /** Whether the option is active or not */\n  active?: boolean;\n  /** Unique identifier for the option */\n  id?: string;\n  /** Media to display to the left of the option content */\n  media?: React.ReactElement<IconProps | ThumbnailProps | AvatarProps>;\n}"},"IconProps":{"filePath":"polaris-react/src/components/Icon/Icon.tsx","name":"IconProps","description":"","members":[{"filePath":"polaris-react/src/components/Icon/Icon.tsx","syntaxKind":"PropertySignature","name":"source","value":"any","description":"The SVG contents to display in the icon (icons should fit in a 20 × 20 pixel viewBox)"},{"filePath":"polaris-react/src/components/Icon/Icon.tsx","syntaxKind":"PropertySignature","name":"tone","value":"Tone","description":"Set the color for the SVG fill","isOptional":true},{"filePath":"polaris-react/src/components/Icon/Icon.tsx","syntaxKind":"PropertySignature","name":"accessibilityLabel","value":"string","description":"Descriptive text to be read to screenreaders","isOptional":true}],"value":"export interface IconProps {\n  /** The SVG contents to display in the icon (icons should fit in a 20 × 20 pixel viewBox) */\n  source: IconSource;\n  /** Set the color for the SVG fill */\n  tone?: Tone;\n  /** Descriptive text to be read to screenreaders */\n  accessibilityLabel?: string;\n}"},"Tone":{"filePath":"polaris-react/src/components/Icon/Icon.tsx","syntaxKind":"TypeAliasDeclaration","name":"Tone","value":"'base' | 'subdued' | 'caution' | 'warning' | 'critical' | 'interactive' | 'info' | 'success' | 'primary' | 'emphasis' | 'magic' | 'textCaution' | 'textWarning' | 'textCritical' | 'textInfo' | 'textSuccess' | 'textPrimary' | 'textMagic'","description":""},"ThumbnailProps":{"filePath":"polaris-react/src/components/Thumbnail/Thumbnail.tsx","name":"ThumbnailProps","description":"","members":[{"filePath":"polaris-react/src/components/Thumbnail/Thumbnail.tsx","syntaxKind":"PropertySignature","name":"size","value":"Size","description":"Size of thumbnail","isOptional":true,"defaultValue":"'medium'"},{"filePath":"polaris-react/src/components/Thumbnail/Thumbnail.tsx","syntaxKind":"PropertySignature","name":"source","value":"any","description":"URL for the image"},{"filePath":"polaris-react/src/components/Thumbnail/Thumbnail.tsx","syntaxKind":"PropertySignature","name":"alt","value":"string","description":"Alt text for the thumbnail image"},{"filePath":"polaris-react/src/components/Thumbnail/Thumbnail.tsx","syntaxKind":"PropertySignature","name":"transparent","value":"boolean","description":"Transparent background","isOptional":true}],"value":"export interface ThumbnailProps {\n  /**\n   * Size of thumbnail\n   * @default 'medium'\n   */\n  size?: Size;\n  /** URL for the image */\n  source: string | React.FunctionComponent<React.SVGProps<SVGSVGElement>>;\n  /** Alt text for the thumbnail image */\n  alt: string;\n  /** Transparent background */\n  transparent?: boolean;\n}"},"Size":{"filePath":"polaris-react/src/components/Thumbnail/Thumbnail.tsx","syntaxKind":"TypeAliasDeclaration","name":"Size","value":"'extraSmall' | 'small' | 'medium' | 'large'","description":""},"AvatarProps":{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","name":"AvatarProps","description":"","members":[{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"PropertySignature","name":"size","value":"Size","description":"Size of avatar","isOptional":true,"defaultValue":"'medium'"},{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"PropertySignature","name":"name","value":"string","description":"The name of the person","isOptional":true},{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"PropertySignature","name":"initials","value":"string","description":"Initials of person to display","isOptional":true},{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"PropertySignature","name":"customer","value":"boolean","description":"Whether the avatar is for a customer","isOptional":true},{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"PropertySignature","name":"source","value":"string","description":"URL of the avatar image which falls back to initials if the image fails to load","isOptional":true},{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"MethodSignature","name":"onError","value":"() => void","description":"Callback fired when the image fails to load","isOptional":true},{"filePath":"polaris-react/src/components/Avatar/Avatar.tsx","syntaxKind":"PropertySignature","name":"accessibilityLabel","value":"string","description":"Accessible label for the avatar image","isOptional":true}],"value":"export interface AvatarProps {\n  /**\n   * Size of avatar\n   * @default 'medium'\n   */\n  size?: Size;\n  /** The name of the person */\n  name?: string;\n  /** Initials of person to display */\n  initials?: string;\n  /** Whether the avatar is for a customer */\n  customer?: boolean;\n  /** URL of the avatar image which falls back to initials if the image fails to load */\n  source?: string;\n  /** Callback fired when the image fails to load  */\n  onError?(): void;\n  /** Accessible label for the avatar image */\n  accessibilityLabel?: string;\n}"},"SectionDescriptor":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","name":"SectionDescriptor","description":"","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"options","value":"OptionDescriptor[]","description":"Collection of options within the section"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"title","value":"string","description":"Section title","isOptional":true}],"value":"export interface SectionDescriptor {\n  /** Collection of options within the section */\n  options: OptionDescriptor[];\n  /** Section title */\n  title?: string;\n}"},"PreferredPosition":{"filePath":"polaris-react/src/components/PositionedOverlay/utilities/math.ts","syntaxKind":"TypeAliasDeclaration","name":"PreferredPosition","value":"'above' | 'below' | 'mostSpace'","description":""},"ActionListItemDescriptor":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","name":"ActionListItemDescriptor","description":"","members":[{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"accessibilityLabel","value":"string","description":"Visually hidden text for screen readers","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"badge","value":"{ tone: \"new\"; content: string; }","description":"","isOptional":true,"deprecationMessage":"Badge component"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"helpText","value":"React.ReactNode","description":"Additional hint text to display with item","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"icon","value":"any","description":"","isOptional":true,"deprecationMessage":"Source of the icon"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"image","value":"string","description":"","isOptional":true,"deprecationMessage":"Image source"},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"prefix","value":"React.ReactNode","description":"Prefix source","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"suffix","value":"React.ReactNode","description":"Suffix source","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"ellipsis","value":"boolean","description":"","isOptional":true,"deprecationMessage":"Add an ellipsis suffix to action content. ellipsis appends `...` without truncating. Use truncate instead."},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"truncate","value":"boolean","description":"Truncate the action content either at the beginning or at the end","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"active","value":"boolean","description":"Whether the action is active or not","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"variant","value":"\"default\" | \"menu\" | \"indented\"","description":"The item variations","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"role","value":"string","description":"Defines a role for the action","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"disabled","value":"boolean","description":"Whether or not the action is disabled","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"id","value":"string","description":"A unique identifier for the action","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"content","value":"string","description":"Content the action displays","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"url","value":"string","description":"A destination to link to, rendered in the action","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"external","value":"boolean","description":"Forces url to open in a new tab","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"target","value":"Target","description":"Where to display the url","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"MethodSignature","name":"onAction","value":"() => void","description":"Callback when an action takes place","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"MethodSignature","name":"onMouseEnter","value":"() => void","description":"Callback when mouse enter","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"MethodSignature","name":"onTouchStart","value":"() => void","description":"Callback when element is touched","isOptional":true},{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"PropertySignature","name":"destructive","value":"boolean","description":"Destructive action","isOptional":true}],"value":"export interface ActionListItemDescriptor\n  extends DisableableAction,\n    DestructableAction {\n  /** Visually hidden text for screen readers */\n  accessibilityLabel?: string;\n  /** @deprecated Badge component */\n  badge?: {\n    tone: 'new';\n    content: string;\n  };\n  /** Additional hint text to display with item */\n  helpText?: React.ReactNode;\n  /** @deprecated Source of the icon */\n  icon?: IconSource;\n  /** @deprecated Image source */\n  image?: string;\n  /** Prefix source */\n  prefix?: React.ReactNode;\n  /** Suffix source */\n  suffix?: React.ReactNode;\n  /** @deprecated Add an ellipsis suffix to action content. ellipsis appends `...` without truncating. Use truncate instead. */\n  ellipsis?: boolean;\n  /** Truncate the action content either at the beginning or at the end */\n  truncate?: boolean;\n  /** Whether the action is active or not */\n  active?: boolean;\n  /** The item variations */\n  variant?: 'default' | 'menu' | 'indented';\n  /** Defines a role for the action */\n  role?: string;\n}"},"Target":{"filePath":"Users/yqtrack/Desktop/shopify-polaris/polaris-main/polaris-react/src/types.ts","syntaxKind":"TypeAliasDeclaration","name":"Target","value":"'_blank' | '_self' | '_parent' | '_top'","description":""},"Overflow":{"filePath":"polaris-react/src/components/Box/Box.tsx","syntaxKind":"TypeAliasDeclaration","name":"Overflow","value":"'hidden' | 'scroll'","description":""}},"editPageLinkPath":"polaris.shopify.com/content/components/selection-and-input/autocomplete.mdx"},"__N_SSG":true}